<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: CT DAC  (Continuous Time Digital to Analog Converter)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__autanalog__dac.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">CT DAC (Continuous Time Digital to Analog Converter)<div class="ingroups"><a class="el" href="group__group__autanalog.html">AUTONOMOUS ANALOG (Autonomous Analog Block)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>This driver provides API functions to configure the CT DAC subsystem of the Autonomous Analog. </p>
<p>The CT DAC (hereafter DAC) is a 12-bit, continuous-time segmented DAC. It is based on an 8-bit R-2R array and a 4-bit thermometer array. A buffered sample and hold (S/H) circuit is useful for low power operation where an occasional update of the DAC output is acceptable. The DAC can be used in applications that require voltage references, bias, or analog waveform output. The DAC can work in conjunction with the CTB and PRB, which are used as buffered reference voltage sources.</p>
<p>The diagram below shows the CT DAC simplified internals.</p>
<p>For more information on the CT DAC, refer to the device Architecture Technical Reference Manual (TRM).<br />
For the exact location of the pins, see the device datasheet.</p>
<div class="image">
<img src="LPPASS_DAC_general.png" alt="LPPASS_DAC_general.png"/>
</div>
<h1><a class="anchor" id="group_autanalog_dac_static"></a>
Static Configuration</h1>
<p>The static configuration contains application-specific settings intended to remain static for any DAC application. The Autonomous Controller (AC) will NOT change the static configuration during operation.</p>
<p>The static configuration of the DAC includes:</p><ul>
<li>Clock rate (for Low Power mode only);</li>
<li>Input data format (signed/unsigned);</li>
<li>Reference voltage source selector;</li>
<li>DAC topology and use of reference and output voltage buffers;</li>
<li>Output control settings;<br />
For configuration settings, refer to <a class="el" href="structcy__stc__autanalog__dac__sta__t.html">cy_stc_autanalog_dac_sta_t</a>.</li>
</ul>
<h1><a class="anchor" id="group_autanalog_dac_channels"></a>
DAC Channels and State Transition Table</h1>
<p>Up to 15 configurations are available for the "virtual" DAC channels. The last channel with index 15 is preserved for updates from FW only.</p>
<p>The DAC channel configuration includes:</p><ul>
<li>Operating mode of the DAC (refer to <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_mode">Operating Mode</a> chapter);</li>
<li>The option to enable the S/H functionality (refer to <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_sampleAndHold">Sample and Hold</a> chapter)</li>
<li>Start/end address and step size for the waveform in the LUT;</li>
<li>Output voltage range;<br />
For the configuration settings, refer to <a class="el" href="structcy__stc__autanalog__dac__ch__t.html" title="The configuration structure of the DAC channel. ">cy_stc_autanalog_dac_ch_t</a> structure.</li>
</ul>
<p>The DAC channel can be switched by the Autonomous Controller (AC) in runtime per settings provided in the State Transition Table (refer to <a class="el" href="structcy__stc__autanalog__stt__dac__t.html">cy_stc_autanalog_stt_dac_t</a> structure)</p>
<h1><a class="anchor" id="group_autanalog_dac_topology"></a>
Topology</h1>
<h2><a class="anchor" id="group_autanalog_dac_vref"></a>
Reference Voltage</h2>
<p>The reference voltage can be Vdda or an internal Vref used with or without the unity gain buffer for the reference voltage in the DAC:</p><ul>
<li>VBGR - Internal, temperature-independent, band-gap voltage reference;</li>
<li>CTB_OA - The reference voltage is driven by the Opamp output in the CTB (refer to <a class="el" href="group__group__autanalog__ctb.html">CTB (Continuous Time Block)</a> section);</li>
<li>PRB_VREF - The reference voltage is driven from the PRB (refer to <a class="el" href="structcy__stc__autanalog__prb__t.html">cy_stc_autanalog_prb_t</a> structure);</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Vdda is 1.8V and Vbgr is 0.9V</dd></dl>
<h2><a class="anchor" id="group_autanalog_dac_path"></a>
Output Paths</h2>
<p>The DAC output can be routed in different paths:</p><ul>
<li>Direct output path (NOT to pin);</li>
<li>Direct output path with Ctrack capacitor connected;</li>
<li>Direct output path with Ctrack and Chold capacitors connected;</li>
<li>Buffered output path for internal connection within the chip;</li>
<li>Buffered output path for internal and external connections;</li>
</ul>
<h1><a class="anchor" id="group_autanalog_dac_pump"></a>
Buffer Input and Output Ranges</h1>
<p>The input range of the buffer can be rail-to-rail if the charge pump is enabled. Without the charge pump, the input range is 0 V to VDDA - 1.5 V. The output range of the buffer is typically 0.2 V to VDDA - 1.0 V and will depend on the load. See the device datasheet for more details.</p>
<table class="doxtable">
<tr>
<th>Charge Pump </th><th>Input Range </th><th>Output Range  </th></tr>
<tr>
<td>Enabled </td><td>0 V to VDDA </td><td>0.2 V to VDDA - 0.2 V  </td></tr>
<tr>
<td>Disabled </td><td>0 V to VDDA - 1.5 V </td><td>0.2 V to VDDA - 1.0 V  </td></tr>
</table>
<p>For the configuration settings, see <a class="el" href="group__group__autanalog__dac__enums.html#gadb9fd3e2d70bd7da9c0fe319be0ca833">cy_en_autanalog_dac_buf_pwr_t</a>.</p>
<h1><a class="anchor" id="group_autanalog_dac_rate"></a>
Update Rates</h1>
<p>The DAC supports two update rates of operation:</p><ul>
<li>Single step mode (default);</li>
<li>Continuous mode;<br />
In Single step mode, the DAC output changes on each subsequent trigger <a class="el" href="structcy__stc__autanalog__stt__dac__t.html#af7c41484566370b872841dbfa8fdeec7" title="This field initiates the DAC operation per selected channel. ">cy_stc_autanalog_stt_dac_t::trigger</a> in the State Transition Table.<br />
In Continuous mode, the output value changes on each subsequent clock of the DAC.<br />
For more details, refer to <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_mode">Operating Mode</a>.</li>
</ul>
<h2><a class="anchor" id="group_autanalog_dac_clock"></a>
Clocking</h2>
<p>The DAC is clocked from the SRSS peripheral clock (Clk_HF9, up to 80MHz, refer to <a class="el" href="group__group__autanalog.html#group_autanalog_section_configuration">General Configuration Considerations</a>) in chip Active mode,<br />
or from the local Low Power Oscillator (LPOSC, 4096kHz, refer to <a class="el" href="group__group__autanalog__ac__enums.html#gaf11e8757f7961367bb1b18a5eeca13ca">cy_en_autanalog_timer_clk_src_t</a>) in chip Deep Sleep mode.<br />
The clock value can also be adjusted using the <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#afbd58859bea2f63b313ad0ae89132865" title="The Low Power clock divider, actual divide value is DIV_VAL + 1, valid range is 1..1024. ">cy_stc_autanalog_dac_sta_t::lpDivDac</a>, which divides the incoming clock in chip Deep Sleep mode.<br />
 </p>
<h1><a class="anchor" id="group_autanalog_dac_sampleAndHold"></a>
Sample and Hold</h1>
<p>The <a class="el" href="structcy__stc__autanalog__dac__ch__t.html#a15db122e0243be449b6b54140c202222" title="Enables Sample and Hold functionality for the DAC, for more details, refer to Sample and Hold...">cy_stc_autanalog_dac_ch_t::sampleAndHold</a> mode allows duty cycling of the DAC where Chold capacitor (Chold &gt;&gt; Ctrack) holds the previous value of the DAC output. The <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#aff41539bdf5608cffbe90b2a3d1caf97" title="The sample time selection for the cy_stc_autanalog_dac_ch_t::sampleAndHold. ">cy_stc_autanalog_dac_sta_t::sampleTime</a> is defined as the time it takes for the DAC output to drop by 1 LSB.</p>
<p>The DAC is updated every positive edge of the DAC clock with the following sequence:</p><ul>
<li>The DAC is configured for SAMPLE: the COS and CHD switches are closed, DAC array is enabled and outputs the updated value (based on <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_mode">Operating Mode</a>) onto a Chold capacitor for sample time duration;</li>
<li>The DAC is configured for HOLD: the COS switch is opened, CHD switch is closed, DAC array is disabled and the last output value is held on the Chold capacitor until the next positive edge of the DAC clock. HOLD duration is DAC clock period - duration of the sample time. <dl class="section note"><dt>Note</dt><dd>For <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_mode">Operating Mode</a> ADDRESS or DATA, the AC must wait (ACTION = WAIT_FOR) for the DAC strobe (CONDITION = DAC_STROBE) before re-triggering the DAC_INC/DAC_DEC fields. Refer to <a class="el" href="group__group__autanalog__ac__enums.html#ga953523ea666a6bd7f2b47eb857c3ba8d">cy_en_autanalog_stt_ac_action_t</a> and <a class="el" href="group__group__autanalog__ac__enums.html#ga07c8c6d1282fb7e5b1f4e4425af6d9d2">cy_en_autanalog_stt_ac_condition_t</a>.</dd></dl>
</li>
</ul>
<h1><a class="anchor" id="group_autanalog_dac_deglitch"></a>
De-glitch</h1>
<p>A typical issue in DACs is the glitch during code transitions. Blanking can be used to reduce the glitch. During data changes, a dedicated switch on the output path is used to block the glitch from propagating to the DAC output. The Ctrack capacitor maintains the previous value while the switch is open, so the DAC output doesn't drop.</p>
<p>If <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#a88d2ca694dd5823b4da9f3ef9de019cc" title="The DAC topology, for more details, refer to Topology chapter. ">cy_stc_autanalog_dac_sta_t::topology</a> is set to</p><ul>
<li>CY_AUTANALOG_DAC_TOPO_DIRECT;</li>
<li>CY_AUTANALOG_DAC_TOPO_DIRECT_WITH_TRACK_CAP;</li>
<li>CY_AUTANALOG_DAC_TOPO_DIRECT_WITH_TRACK_HOLD_CAP;</li>
</ul>
<p>the CHD switch is opened during the de-glitch time.</p>
<p>If <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#a88d2ca694dd5823b4da9f3ef9de019cc" title="The DAC topology, for more details, refer to Topology chapter. ">cy_stc_autanalog_dac_sta_t::topology</a> is set to</p><ul>
<li>CY_AUTANALOG_DAC_TOPO_BUFFERED_INTERNAL;</li>
<li>CY_AUTANALOG_DAC_TOPO_BUFFERED_EXTERNAL;</li>
</ul>
<p>the COS switch is opened during the de-glitch time.</p>
<p>De-glitch time set with <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#a7a034e09f6997d47de773f9cceda7531" title="The DAC de-glitch time, for more details, refer to De-glitch Actual value is DEGLITCH_CNT + 1...">cy_stc_autanalog_dac_sta_t::deGlitchTime</a> and calculated as follow:<br />
(DEGLITCH_CNT + 1) / DAC_CLOCK_FREQ</p>
<h1><a class="anchor" id="group_autanalog_dac_mode"></a>
Operating Mode</h1>
<table class="doxtable">
<tr>
<th>Mode </th><th>Description  </th></tr>
<tr>
<td>One Shot, One Quadrant </td><td>The LUT address is incremented on every positive edge of the DAC clock until the END_ADDR is reached or exceeded.<br />
 The update step size is defined by STEP_VAL.<br />
 The One Shot mode is completed when the END_ADDR is reached.<br />
 The DAC outputs an EPOCH trigger after reaching (or exceeding) the END_ADDR and outputting the corresponding value.   </td></tr>
<tr>
<td>One Shot, Two Quadrant </td><td>The LUT address is incremented on every positive edge of the DAC clock until the END_ADDR is reached*, then the LUT address is decremented back to the START_ADDR.<br />
 The DAC outputs an EPOCH trigger after returning to (or exceeding) the START_ADDR and outputting the corresponding value. <dl class="section note"><dt>Note</dt><dd>*If the END_ADDR is not reached but exceeded (which can happen with STEP_VAL greater than 1), the LUT address is decremented from the END_ADDR by the amount exceeded).   </dd></dl>
</td></tr>
<tr>
<td>One Shot, Four Quadrant </td><td>The LUT address is updated on every positive edge of the DAC clock according to the following algorithm:<br />
<ol type="1">
<li>The LUT address is incremented until the END_ADDR is reached*<br />
</li>
<li>The LUT address is decremented until the START_ADDR is reached*<br />
</li>
<li>The polarity of the DAC output signal is inverted and steps 1 and 2 are repeated<br />
 The DAC outputs an EPOCH trigger after returning to (or exceeding) the START_ADDR with an inverted polarity and outputting the corresponding value.<br />
 This mode assumes that the DAC waveform table constitutes 1/4 of the desired generated waveform. <dl class="section note"><dt>Note</dt><dd><em>If the START_ADDR/END_ADDR address is not reached but instead exceeded (which can happen with STEP_VAL greater than 1), the LUT address is adjusted (i.e. decremented from END_ADDR or incremented from START_ADDR by the amount exceeded).   </em></dd></dl>
</li>
</ol>
</td></tr>
<tr>
<td><em>Continuous, One Quadrant </em></td><td><em> The LUT address is incremented on every positive edge of the DAC clock until the END_ADDR is reached</em>.<br />
 The address then wraps back to the START_ADDR and repeats indefinitely.<br />
 The update step size is defined by STEP_VAL.<br />
 The DAC outputs an EPOCH trigger after reaching (or exceeding) the END_ADDR and outputting the corresponding value. <dl class="section note"><dt>Note</dt><dd><em>If the END_ADDR is not reached, but instead exceeded (which can happen with STEP_VAL greater than 1), the LUT address wraps back to START_ADDR and is incremented by the amount exceeded).   </em></dd></dl>
</td></tr>
<tr>
<td><em>Continuous, Two Quadrant </em></td><td><em> The LUT address is incremented on every positive edge of the DAC clock until the END_ADDR is reached</em>, then the LUT address is decremented back to the START_ADDR and repeats indefinitely.<br />
 The DAC outputs an EPOCH trigger after returning to the START_ADDR and outputting the corresponding value. <dl class="section note"><dt>Note</dt><dd>*If the START_ADDR or the END_ADDR is not reached but instead exceeded (which can happen with STEP_VAL greater than 1), the LUT address is adjusted (i.e. decremented from END_ADDR or incremented from START_ADDR by the amount exceeded).   </dd></dl>
</td></tr>
<tr>
<td>Continuous, Four Quadrant </td><td>The LUT address is updated on every positive edge of the DAC clock according to the following algorithm:<br />
<ol type="1">
<li>The LUT address is incremented until the END_ADDR is reached*.</li>
<li>The LUT address is decremented until the START_ADDR is reached*.</li>
<li>The polarity of the DAC output signal is inverted and steps 1 and 2 are repeated indefinitely.<br />
 The DAC outputs an EPOCH trigger after returning to (or exceeding) the START_ADDR with an inverted polarity and outputting the corresponding value.<br />
 This mode assumes that the DAC waveform table constitutes 1/4 of the desired generated waveform. <dl class="section note"><dt>Note</dt><dd>*If the START_ADDR/END_ADDR is not reached but instead exceeded (which can happen with STEP_VAL greater than 1), the LUT address is adjusted (i.e. decremented from END_ADDR or incremented from STAR_ADDR by the amount exceeded).   </dd></dl>
</li>
</ol>
</td></tr>
<tr>
<td>Address mode </td><td>The LUT address is updated on every positive edge of the DAC_INC or DAC_DEC from the State Transition Table, see <a class="el" href="structcy__stc__autanalog__stt__dac__t.html#a794925e2fac41db7573c5389f5bccdef" title="Defines the direction of movement in the LUT or the increment/decrement of the DAC value...">cy_stc_autanalog_stt_dac_t::direction</a>, unless cy_stc_autanalog_dac_ch_t::sampleAndhold is set<br />
 (for more details, refer to <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_sampleAndHold">Sample and Hold</a> chapter).<br />
 The update step size is defined by STEP_VAL.<br />
 If on the START_ADDR and DAC_DEC is triggered, the address wraps forward to the END_ADDR.<br />
 If on the END_ADDR and DAC_INC is triggered, the address wraps back to the START_ADDR.<br />
 <dl class="section note"><dt>Note</dt><dd>In this mode, the DAC does not output an EPOCH trigger.   </dd></dl>
</td></tr>
<tr>
<td>Data mode </td><td>The DAC outputs the data stored at the START_ADDR.<br />
 The DAC output value is incremented or decremented based on every positive edge of the DAC_INC or DAC_DEC from the State Transition Table, see <a class="el" href="structcy__stc__autanalog__stt__dac__t.html#a794925e2fac41db7573c5389f5bccdef" title="Defines the direction of movement in the LUT or the increment/decrement of the DAC value...">cy_stc_autanalog_stt_dac_t::direction</a>, unless cy_stc_autanalog_dac_ch_t::sampleAndhold is set<br />
 (for more details, refer to <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_sampleAndHold">Sample and Hold</a> chapter).<br />
 The increment/decrement amount is set by STEP_VAL.<br />
 <dl class="section note"><dt>Note</dt><dd>In this mode, the DAC does not output an EPOCH trigger. </dd>
<dd>
The DAC value is clamped if requested to go under the minimum code (0x000 for unsigned or 0x800 for signed) or above the maximum code (0xFFF for unsigned or 0x7FF for signed).   </dd></dl>
</td></tr>
</table>
<p>Where START_ADDR, END_ADDR and STEP_VAL are configured individually for each channel:</p><ul>
<li>The START_ADDR is defined in <a class="el" href="structcy__stc__autanalog__dac__ch__t.html#a31f44cfa1ebbc2899771c34c0e37682f" title="Start address of the waveform in the LUT. ">cy_stc_autanalog_dac_ch_t::startAddr</a>;<br />
</li>
<li>The END_ADDR is defined in <a class="el" href="structcy__stc__autanalog__dac__ch__t.html#a4c2596f980334bdd6dad6a94c4bdf781" title="End address of the waveform in the LUT. ">cy_stc_autanalog_dac_ch_t::endAddr</a>;<br />
</li>
<li>The STEP_VAL is selected in <a class="el" href="structcy__stc__autanalog__dac__ch__t.html#afee1c640aac7f610dbc4712bd0c882d4" title="The step selector for the DAC. ">cy_stc_autanalog_dac_ch_t::stepSel</a>.<br />
 For the configuration settings, see <a class="el" href="structcy__stc__autanalog__dac__ch__t.html#a4322c4a53f6be9e300b812b8b854ff7e">cy_stc_autanalog_dac_ch_t::operMode</a>.</li>
</ul>
<h1><a class="anchor" id="group_autanalog_dac_output"></a>
Output Drive Control</h1>
<p>The DAC can be programmed so that code 0 corresponds to ground or 1 LSB. The bottom end of the R-2R ladder (LSB side) can be configured to connect to the Vref or Vssa using <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#a830f895bcbe36c73eb2d79d77e4583fa" title="The selector for the connecting the bottom end of the R-2R resistors ladder, for more details...">cy_stc_autanalog_dac_sta_t::bottomSel</a>. This setting determines the output drive control in row with <a class="el" href="structcy__stc__autanalog__stt__dac__t.html#abf532303f460e0766f8529babdb50824" title="Enables the DAC. ">cy_stc_autanalog_stt_dac_t::enable</a>, <a class="el" href="structcy__stc__autanalog__dac__waveform__t.html#aa41f528c36f72fb0abd52e76efa76577" title="The pointer to the drive mode configurations. ">cy_stc_autanalog_dac_waveform_t::driveMode</a> and <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#a60d5b1938f8cc390fd3d5d8db00a1acf" title="The selector for the DAC output value when the output is disabled, for more details, refer to Output Drive Control chapter. ">cy_stc_autanalog_dac_sta_t::disabledMode</a> as follow:</p>
<table class="doxtable">
<tr>
<th>DAC Enabled </th><th>Drive Mode </th><th>Disabled Mode </th><th>DAC Range </th><th>Output State  </th></tr>
<tr>
<td>FALSE </td><td>X </td><td>X </td><td>X </td><td>tri-state  </td></tr>
<tr>
<td>TRUE </td><td>Hi-Z </td><td>tri-state </td><td>X </td><td>tri-state  </td></tr>
<tr>
<td>TRUE </td><td>Hi-Z </td><td>Vssa/Vref </td><td>Vssa </td><td>Vssa  </td></tr>
<tr>
<td>TRUE </td><td>Hi-Z </td><td>Vssa/Vref </td><td>Vref </td><td>Vref  </td></tr>
<tr>
<td>TRUE </td><td>Vref </td><td>tri-state </td><td>X </td><td>tri-state  </td></tr>
<tr>
<td>TRUE </td><td>Vref </td><td>Vssa/Vref </td><td>Vssa </td><td>Vssa  </td></tr>
<tr>
<td>TRUE </td><td>Vref </td><td>Vssa/Vref </td><td>Vref </td><td>Vref  </td></tr>
<tr>
<td>TRUE </td><td>Enabled </td><td>X </td><td>Vssa </td><td>[0, 4095] * Vref / 4096  </td></tr>
<tr>
<td>TRUE </td><td>Enabled </td><td>X </td><td>Vref </td><td>[1, 4096] * Vref / 4096  </td></tr>
</table>
<h1><a class="anchor" id="group_autanalog_dac_sign"></a>
Signed/Unsigned Input</h1>
<p>The format of the DAC code can be either unsigned or signed two's complement. Only the first 12 bits are used by the DAC, so no sign extension is required. For the signed format, the DAC decodes the input code by adding 0x800.<br />
 For the configuration settings, see <a class="el" href="structcy__stc__autanalog__dac__sta__t.html#a47ced588cf0e917bfc50c44dcb682159">cy_stc_autanalog_dac_sta_t::sign</a>.</p>
<h1><a class="anchor" id="group_autanalog_dac_int"></a>
Interrupts, Triggers and STT Events</h1>
<p>The following internal events of the DAC can be configured to generate an interrupt or trigger or used as the STT event in the Autonomous Analog (refer to <a class="el" href="group__group__autanalog__ac__enums.html#ga768fe80c98ba584dd74ba62278d57b31">cy_en_autanalog_ac_out_trigger_mask_t</a> and <a class="el" href="group__group__autanalog__ac__enums.html#ga07c8c6d1282fb7e5b1f4e4425af6d9d2">cy_en_autanalog_stt_ac_condition_t</a>):</p><ul>
<li>DAC_EPOCH - Indicates end of waveform event;</li>
<li>DAC_RANGE - Indicates range detection conditions;</li>
<li>DAC_EMPTY (interrupt only) - Indicates empty conditions on FW channel (Ch#15), refer to <a class="el" href="group__group__autanalog__dac__functions.html#ga8c9f0e0f89cdb2f3b81b1ff8eebebc03">Cy_AutAnalog_DAC_WriteNextSample</a> ;</li>
<li>DAC_STROBE (STT event only) - Indicates the S/H iteration finished (refer to <a class="el" href="group__group__autanalog__dac.html#group_autanalog_dac_sampleAndHold">Sample and Hold</a> chapter);</li>
</ul>
<h1><a class="anchor" id="group_autanalog_dac_sample1"></a>
Sample use case: FW Channel #15</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Define the index for DAC0 instance within the Autonomous Analog */</span></div><div class="line"><span class="preprocessor">#define DAC0IDX                                                 (0U)</span></div><div class="line"><span class="comment">/* Define the index for DAC1 instance within the Autonomous Analog */</span></div><div class="line"><span class="preprocessor">#define DAC1IDX                                                 (1U)</span></div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Scenario 1:</span></div><div class="line"><span class="comment"> * CT DAC is used to generate bias 0.7V (DAC code: (0.7 / 1.8) * 2^12 = 0x639).</span></div><div class="line"><span class="comment"> * DAC0 is controlled by the FW channel and</span></div><div class="line"><span class="comment"> * configured to operate in Ultra-low power mode with Vdda (1.8V) as Vref.</span></div><div class="line"><span class="comment"> * Note: No channel configuration is required in this case.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="comment">/* Configuration of range conditions for DAC0 */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="structcy__stc__autanalog__dac__ch__limit__t.html">cy_stc_autanalog_dac_ch_limit_t</a> dac0Ch15StatusCfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__autanalog__dac__ch__limit__t.html#a23c7f0bf131426aa7edd968b8817526b">cond</a> = <a class="code" href="group__group__autanalog__dac__enums.html#gga4fe34911a518f56ab789ec68b904d489a44b696fd63fc6a52bbedc1a73fd017c3">CY_AUTANALOG_DAC_CH_LIMIT_OUTSIDE</a>,</div><div class="line">    .low  = 0x638,</div><div class="line">    .high = 0x640,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* The static part of the configuration for DAC0 */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="structcy__stc__autanalog__dac__sta__t.html">cy_stc_autanalog_dac_sta_t</a> dac0StaCfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__autanalog__dac__sta__t.html#afbd58859bea2f63b313ad0ae89132865">lpDivDac</a>      = 1023U,                                     <span class="comment">/* DAC clock: 4096kHz / 1024 = 4kHz, but not in use */</span></div><div class="line">    .topology      = <a class="code" href="group__group__autanalog__dac__enums.html#ggadf18ff8fe6bc7017c4690f6690570b39ad94c126119708a6707f588247a05941a">CY_AUTANALOG_DAC_TOPO_BUFFERED_EXTERNAL</a>,   <span class="comment">/* DAC output buffered for external use */</span></div><div class="line">    .vrefSel       = <a class="code" href="group__group__autanalog__dac__enums.html#ggad9f770740f1eb74af3dd7610a8294df8a9484064995023e1e47b11cd59aebd008">CY_AUTANALOG_DAC_VREF_VDDA</a>,                <span class="comment">/* DAC reference voltage is Vdda */</span></div><div class="line">    .deGlitch      = <span class="keyword">false</span>,                                     <span class="comment">/* Not used for static voltage */</span></div><div class="line">    .bottomSel     = <span class="keyword">false</span>,                                     <span class="comment">/* DAC output range: [0, 4095] * Vref / 4096 */</span></div><div class="line">    .disabledMode  = <span class="keyword">true</span>,                                      <span class="comment">/* If DAC is not enabled, output is Vssa */</span></div><div class="line">    .refBuffPwr    = <a class="code" href="group__group__autanalog__dac__enums.html#ggadb9fd3e2d70bd7da9c0fe319be0ca833ae7a4636b5b5cf777ecb39753695aff88">CY_AUTANALOG_DAC_BUF_PWR_OFF</a>,              <span class="comment">/* Buffer is not used when Vdda is selected as reference */</span></div><div class="line">    .outBuffPwr    = <a class="code" href="group__group__autanalog__dac__enums.html#ggadb9fd3e2d70bd7da9c0fe319be0ca833ad259b7de5e99da118320f5bd59eafc41">CY_AUTANALOG_DAC_BUF_PWR_ULTRA_LOW</a>,        <span class="comment">/* Charge pump not used */</span></div><div class="line">    .sign          = <span class="keyword">false</span>,                                     <span class="comment">/* Unsigned data format used */</span></div><div class="line">    .vrefMux       = <a class="code" href="group__group__autanalog__dac__enums.html#gga19e5862fddcb1a280cb4732f583ba932a7a836559265c90f66513eea5c4bfe3f9">CY_AUTANALOG_DAC_VREF_MUX_VBGR</a>,            <span class="comment">/* Multiplexer not used if Vref is Vdda */</span></div><div class="line">    .sampleTime    = 0U,                                        <span class="comment">/* Not in use */</span></div><div class="line">    .stepVal       = {0U, 0U, 0U},                              <span class="comment">/* Not used for FW channel */</span></div><div class="line">    .deGlitchTime  = 0U,                                        <span class="comment">/* Not used for static voltage */</span></div><div class="line">    .chCfg         = {NULL},                                    <span class="comment">/* Not used for FW channel */</span></div><div class="line">    .chLimitCfg    = {&amp;dac0Ch15StatusCfg, NULL, NULL},          <span class="comment">/* Check that the DAC0 input is in the range */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Total configuration for DAC0 */</span></div><div class="line"><a class="code" href="structcy__stc__autanalog__dac__t.html">cy_stc_autanalog_dac_t</a> dac0Cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__autanalog__dac__t.html#ab7e8037710ad56a7780afcd4ae967e5d">dacStaCfg</a> = &amp;dac0StaCfg,</div><div class="line">    .waveform  = NULL,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* The State Transition Table configuration for DAC0 */</span></div><div class="line"><a class="code" href="structcy__stc__autanalog__stt__dac__t.html">cy_stc_autanalog_stt_dac_t</a> dac0Tt[] =</div><div class="line">{</div><div class="line">    <span class="comment">/* The single state configuration in the State Transition Table */</span></div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__autanalog__stt__dac__t.html#aa9a614fa49d1793766214cc4207a1404">unlock</a>    = <span class="keyword">true</span>,                                      <span class="comment">/* The data are valid */</span></div><div class="line">        .enable    = <span class="keyword">true</span>,                                      <span class="comment">/* Enable DAC0 */</span></div><div class="line">        .trigger   = <span class="keyword">false</span>,                                     <span class="comment">/* Not used for FW channel */</span></div><div class="line">        .channel   = 15U,                                       <span class="comment">/* Not used for FW channel */</span></div><div class="line">        .direction = <a class="code" href="group__group__autanalog__dac__enums.html#gga6d8b4ad5057800a141753126211afaa9afb2a2df0d88cc2e471235b2a5532d56b">CY_AUTANALOG_DAC_DIRECTION_FORWARD</a>,        <span class="comment">/* Not in use */</span></div><div class="line">    },</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The configuration must be done only under the AC in High Speed mode, when <a class="el" href="structcy__stc__autanalog__stt__ac__t.html#ad8b755e2429d3d4f210b2571afe56950">cy_stc_autanalog_stt_ac_t::lpMode</a> is equal to FALSE.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group__group__autanalog__enums.html#ga720c4a47874d251fb7e46aff083507e7">cy_en_autanalog_status_t</a> status;</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Load configuration for DAC0 */</span></div><div class="line">    status = <a class="code" href="group__group__autanalog__dac__functions__init.html#ga8ed11e1699dad6710117971f2fc8cca4">Cy_AutAnalog_DAC_LoadConfig</a>(DAC0IDX, &amp;dac0Cfg);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__autanalog__enums.html#gga720c4a47874d251fb7e46aff083507e7ae5d7d4a174f8f9099b94ced1cc863143">CY_AUTANALOG_SUCCESS</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Generate bias 0.7V at the DAC0 output */</span></div><div class="line">    <a class="code" href="group__group__autanalog__dac__functions.html#ga8c9f0e0f89cdb2f3b81b1ff8eebebc03">Cy_AutAnalog_DAC_WriteNextSample</a>(DAC0IDX, 0x639);</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="group_autanalog_dac_sample2"></a>
Sample use case: Output Analog Waveform</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Define the index for DAC0 instance within the Autonomous Analog */</span></div><div class="line"><span class="preprocessor">#define DAC0IDX                                                 (0U)</span></div><div class="line"><span class="comment">/* Define the index for DAC1 instance within the Autonomous Analog */</span></div><div class="line"><span class="preprocessor">#define DAC1IDX                                                 (1U)</span></div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Define the channel index for the waveform */</span></div><div class="line"><span class="preprocessor">#define WAVEFORM_CH_IDX                                         (0U)</span></div><div class="line"><span class="comment">/* Define the number of samples in the waveform */</span></div><div class="line"><span class="preprocessor">#define WAVEFORM_SUMPLES_NUM                                    (6U)</span></div><div class="line"><span class="comment">/* Start index of the waveform in the LUT */</span></div><div class="line"><span class="preprocessor">#define WAVEFORM_START_IDX                                      (0U)</span></div><div class="line"><span class="comment">/* End index of the waveform in the LUT */</span></div><div class="line"><span class="preprocessor">#define WAVEFORM_END_IDX                                        (5U)</span></div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Scenario 2:</span></div><div class="line"><span class="comment"> * CT DAC is used to output analog waveform.</span></div><div class="line"><span class="comment"> * DAC1 is configured to operate in Ultra-low power mode with Vref 0.9V provided by PRB.</span></div><div class="line"><span class="comment"> * Ch0 is configured to operate in continuous four quadrant mode, with frequency ~171kHz</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * One period of the waveform is shown below:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     V</span></div><div class="line"><span class="comment"> *      ^</span></div><div class="line"><span class="comment"> * 0.88-|-     ******</span></div><div class="line"><span class="comment"> *      |      |     |</span></div><div class="line"><span class="comment"> * 0.66-|-  ***      ***</span></div><div class="line"><span class="comment"> *      |   |           |</span></div><div class="line"><span class="comment"> * 0.44-|---|-----------|-----------|---</span></div><div class="line"><span class="comment"> *      |               |           |</span></div><div class="line"><span class="comment"> * 0.22-|-              ***      ***</span></div><div class="line"><span class="comment"> *      |                  |     |</span></div><div class="line"><span class="comment"> * 0.00-|------------------******-----------&gt; t</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &quot;*&quot; - means duration of 1 DAC clock, waveform period is 24 DAC clocks;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * CONT_FOUR_QUAD mode requires only 6 samples with two levels to create a complete waveform:</span></div><div class="line"><span class="comment"> * 0.88V - 0x0FFFU</span></div><div class="line"><span class="comment"> * 0.66V - X</span></div><div class="line"><span class="comment"> * X = 0x0BFF;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The optimal and recommended de-glitch time is 700 ns,</span></div><div class="line"><span class="comment"> * DEGLITCH_CNT + 1 = 700ns * 4096kHz = 3</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="comment">/* Definition of the waveform data */</span></div><div class="line"><span class="keyword">static</span> int16_t waveform[WAVEFORM_SUMPLES_NUM] =</div><div class="line">{</div><div class="line">    0x0BFFU,</div><div class="line">    0x0BFFU,</div><div class="line">    0x0BFFU,</div><div class="line">    0x0FFFU,</div><div class="line">    0x0FFFU,</div><div class="line">    0x0FFFU,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Configuration of the drive mode */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="group__group__autanalog__dac__enums.html#gac77ea9db84a24c7741551e92022a7083">cy_en_autanalog_dac_out_drive_mode_t</a> driveModeArr[WAVEFORM_SUMPLES_NUM] =</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__autanalog__dac__enums.html#ggac77ea9db84a24c7741551e92022a7083a3d7742ed147c4fa7c8f8dba38c207795">CY_AUTANALOG_DAC_OUT_DRIVE_MODE_EN</a></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Configuration of the waveform */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="structcy__stc__autanalog__dac__waveform__t.html">cy_stc_autanalog_dac_waveform_t</a> dac1Waveform =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__autanalog__dac__waveform__t.html#adc727258f5bc901e34d7d2b4fe36cc1b">numSamples</a> = WAVEFORM_SUMPLES_NUM,</div><div class="line">    .waveformData = waveform,</div><div class="line">    .isDriveModeArray = <span class="keyword">true</span>,</div><div class="line">    .driveMode = driveModeArr,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Configuration of Ch0 for DAC1 */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="structcy__stc__autanalog__dac__ch__t.html">cy_stc_autanalog_dac_ch_t</a> dac1Ch0Cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__autanalog__dac__ch__t.html#a31f44cfa1ebbc2899771c34c0e37682f">startAddr</a>     = WAVEFORM_START_IDX,                        <span class="comment">/* Index 0 in the LUT */</span></div><div class="line">    .endAddr       = WAVEFORM_END_IDX,                          <span class="comment">/* Index 5 in the LUT */</span></div><div class="line">    .operMode      = <a class="code" href="group__group__autanalog__dac__enums.html#gga2c62cdae0aa74d8a1ea07bb5064e36b2a751e93c7cbff9190143581c31c2d15ea">CY_AUTANALOG_DAC_LUT_CONT_FOUR_QUAD</a>,       <span class="comment">/* Continuous four quadrant mode */</span></div><div class="line">    .sampleAndHold = <span class="keyword">false</span>,                                     <span class="comment">/* Not used in waveform mode */</span></div><div class="line">    .stepSel       = <a class="code" href="group__group__autanalog__dac__enums.html#gga4f354bd33ca133fb79b3ebb15b471c93a4aaa83edb79f28100c7503e64c148bfc">CY_AUTANALOG_DAC_STEP_SEL_DISABLED</a>,        <span class="comment">/* Step value is 1 by default */</span></div><div class="line">    .statSel       = <a class="code" href="group__group__autanalog__dac__enums.html#ggab05fba5dfa81d090fa68f77248b22e04a329d6379e8d0116b2a3f4fd3006997ad">CY_AUTANALOG_DAC_STATUS_SEL_DISABLED</a>,      <span class="comment">/* Not in use */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* The static part of the configuration for the DAC1 */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="structcy__stc__autanalog__dac__sta__t.html">cy_stc_autanalog_dac_sta_t</a> dac1StaCfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__autanalog__dac__sta__t.html#afbd58859bea2f63b313ad0ae89132865">lpDivDac</a>      = 0U,                                        <span class="comment">/* DAC clock: 4096kHz */</span></div><div class="line">    .topology      = <a class="code" href="group__group__autanalog__dac__enums.html#ggadf18ff8fe6bc7017c4690f6690570b39ad94c126119708a6707f588247a05941a">CY_AUTANALOG_DAC_TOPO_BUFFERED_EXTERNAL</a>,   <span class="comment">/* DAC output buffered for external use */</span></div><div class="line">    .vrefSel       = <a class="code" href="group__group__autanalog__dac__enums.html#ggad9f770740f1eb74af3dd7610a8294df8a333a926bb2d42718c6b63632c438fb49">CY_AUTANALOG_DAC_VREF_MUX_OUT</a>,             <span class="comment">/* DAC reference voltage is 0.9V from PRB */</span></div><div class="line">    .deGlitch      = <span class="keyword">true</span>,                                      <span class="comment">/* Enabled for generation smooth waveform */</span></div><div class="line">    .bottomSel     = <span class="keyword">false</span>,                                     <span class="comment">/* DAC output range: [0, 4095] * Vref / 4096 */</span></div><div class="line">    .disabledMode  = <span class="keyword">true</span>,                                      <span class="comment">/* If DAC is not enabled, output is Vssa */</span></div><div class="line">    .refBuffPwr    = <a class="code" href="group__group__autanalog__dac__enums.html#ggadb9fd3e2d70bd7da9c0fe319be0ca833a1aeb6f83d95c1a3e2abad654a49d3644">CY_AUTANALOG_DAC_BUF_PWR_ULTRA_LOW_RAIL</a>,   <span class="comment">/* Use full range of reference voltages */</span></div><div class="line">    .outBuffPwr    = <a class="code" href="group__group__autanalog__dac__enums.html#ggadb9fd3e2d70bd7da9c0fe319be0ca833ad259b7de5e99da118320f5bd59eafc41">CY_AUTANALOG_DAC_BUF_PWR_ULTRA_LOW</a>,        <span class="comment">/* DAC output voltage is below Vdda */</span></div><div class="line">    .sign          = <span class="keyword">false</span>,                                     <span class="comment">/* Unsigned data format used */</span></div><div class="line">    .vrefMux       = <a class="code" href="group__group__autanalog__dac__enums.html#gga19e5862fddcb1a280cb4732f583ba932ac6d05caaf51b70774e7db108cfc965f4">CY_AUTANALOG_DAC_VREF_MUX_PRB_VREF0</a>,       <span class="comment">/* PRB0 provides reference voltage */</span></div><div class="line">    .sampleTime    = 0U,                                        <span class="comment">/* Not used in waveform mode */</span></div><div class="line">    .stepVal       = {0U, 0U, 0U},                              <span class="comment">/* Step value is 1 by default */</span></div><div class="line">    .deGlitchTime  = 2U,                                        <span class="comment">/* See DEGLITCH_CNT calculation */</span></div><div class="line">    .chCfg         = {&amp;dac1Ch0Cfg, },</div><div class="line">    .chLimitCfg    = {NULL},</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Total configuration for the DAC1 */</span></div><div class="line"><a class="code" href="structcy__stc__autanalog__dac__t.html">cy_stc_autanalog_dac_t</a> dac1Cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__autanalog__dac__t.html#ab7e8037710ad56a7780afcd4ae967e5d">dacStaCfg</a> = &amp;dac1StaCfg,</div><div class="line">    .waveform  = &amp;dac1Waveform,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* The State Transition Table configuration for the DAC1 */</span></div><div class="line"><a class="code" href="structcy__stc__autanalog__stt__dac__t.html">cy_stc_autanalog_stt_dac_t</a> dac1Tt[] =</div><div class="line">{</div><div class="line">    <span class="comment">/* The single state configuration in the State Transition Table */</span></div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__autanalog__stt__dac__t.html#aa9a614fa49d1793766214cc4207a1404">unlock</a>    = <span class="keyword">true</span>,                                      <span class="comment">/* The data are valid */</span></div><div class="line">        .enable    = <span class="keyword">true</span>,                                      <span class="comment">/* Enable DAC1 */</span></div><div class="line">        .trigger   = <span class="keyword">true</span>,                                      <span class="comment">/* Start waveform generation */</span></div><div class="line">        .channel   = WAVEFORM_CH_IDX,                           <span class="comment">/* Channel #0 is selected for waveform */</span></div><div class="line">        .direction = <a class="code" href="group__group__autanalog__dac__enums.html#gga6d8b4ad5057800a141753126211afaa9afb2a2df0d88cc2e471235b2a5532d56b">CY_AUTANALOG_DAC_DIRECTION_FORWARD</a>,        <span class="comment">/* Data stored in the LUT in ascending order */</span></div><div class="line">    },</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The configuration must be done only under the AC in High Speed mode, when <a class="el" href="structcy__stc__autanalog__stt__ac__t.html#ad8b755e2429d3d4f210b2571afe56950">cy_stc_autanalog_stt_ac_t::lpMode</a> is equal to FALSE.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group__group__autanalog__enums.html#ga720c4a47874d251fb7e46aff083507e7">cy_en_autanalog_status_t</a> status;</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line">    status = <a class="code" href="group__group__autanalog__dac__functions__init.html#ga8ed11e1699dad6710117971f2fc8cca4">Cy_AutAnalog_DAC_LoadConfig</a>(DAC1IDX, &amp;dac1Cfg);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__autanalog__enums.html#gga720c4a47874d251fb7e46aff083507e7ae5d7d4a174f8f9099b94ced1cc863143">CY_AUTANALOG_SUCCESS</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Error handling */</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__autanalog__dac__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__autanalog__dac__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__autanalog__dac__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__autanalog__dac__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__autanalog__dac__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__autanalog__dac__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__autanalog__dac__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__autanalog__dac__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
