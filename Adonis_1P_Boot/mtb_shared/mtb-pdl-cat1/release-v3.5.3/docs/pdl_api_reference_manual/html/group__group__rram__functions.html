<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__rram__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__rram.html">RRAM         (Resistive Random Access Memory)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<dl class="section note"><dt>Note</dt><dd>In order to acquire PC_LOCK from CM33 the bootrow(0x50100000) value should be updated with 0xdb, 0x00, 0x00, 0x00, 0x70, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 where 0xdb should be written at 0th offset. Bootrow can be updated using <a class="el" href="group__group__rram__functions.html#gaccc1c7abb8466ba7f5643bfdcdd495bb">Cy_RRAM_OtpReadByteArray()</a> API. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab63a4b927a0745e0342b0de9c8c46482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#gab63a4b927a0745e0342b0de9c8c46482">Cy_RRAM_OtpWriteByteArray</a> (RRAMC_Type *base, uint32_t addr, const uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:gab63a4b927a0745e0342b0de9c8c46482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes array of byte data to the specified address.  <a href="#gab63a4b927a0745e0342b0de9c8c46482">More...</a><br /></td></tr>
<tr class="separator:gab63a4b927a0745e0342b0de9c8c46482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc1c7abb8466ba7f5643bfdcdd495bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#gaccc1c7abb8466ba7f5643bfdcdd495bb">Cy_RRAM_OtpReadByteArray</a> (RRAMC_Type *base, uint32_t addr, uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:gaccc1c7abb8466ba7f5643bfdcdd495bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads array of byte data from the specified address.  <a href="#gaccc1c7abb8466ba7f5643bfdcdd495bb">More...</a><br /></td></tr>
<tr class="separator:gaccc1c7abb8466ba7f5643bfdcdd495bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590fa451d221ea4f1027bfc549b024ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga590fa451d221ea4f1027bfc549b024ae">Cy_RRAM_OtpWriteWord</a> (RRAMC_Type *base, uint32_t addr, uint32_t data)</td></tr>
<tr class="memdesc:ga590fa451d221ea4f1027bfc549b024ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 32-bit word data to the specified address.  <a href="#ga590fa451d221ea4f1027bfc549b024ae">More...</a><br /></td></tr>
<tr class="separator:ga590fa451d221ea4f1027bfc549b024ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7b3b7eef4f26a45fafd4962ded3395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#gaed7b3b7eef4f26a45fafd4962ded3395">Cy_RRAM_OtpReadWord</a> (RRAMC_Type *base, uint32_t addr, uint32_t *data)</td></tr>
<tr class="memdesc:gaed7b3b7eef4f26a45fafd4962ded3395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32bit word data from the specified address.  <a href="#gaed7b3b7eef4f26a45fafd4962ded3395">More...</a><br /></td></tr>
<tr class="separator:gaed7b3b7eef4f26a45fafd4962ded3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7dbd1a2bf852a5652771b40048f15c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga7c7dbd1a2bf852a5652771b40048f15c">Cy_RRAM_OtpWriteBlock</a> (RRAMC_Type *base, uint32_t addr, uint8_t *data)</td></tr>
<tr class="memdesc:ga7c7dbd1a2bf852a5652771b40048f15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a block(16B) data to the specified address.  <a href="#ga7c7dbd1a2bf852a5652771b40048f15c">More...</a><br /></td></tr>
<tr class="separator:ga7c7dbd1a2bf852a5652771b40048f15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e80ece896f80a3eb042d1d7b7b2bb1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a> (RRAMC_Type *base, uint32_t addr, const uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga7e80ece896f80a3eb042d1d7b7b2bb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes array of byte data to the specified address in blocking mode.  <a href="#ga7e80ece896f80a3eb042d1d7b7b2bb1d">More...</a><br /></td></tr>
<tr class="separator:ga7e80ece896f80a3eb042d1d7b7b2bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8561326cff8a7cb711980b59dc8d25ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a> (RRAMC_Type *base, uint32_t addr, uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga8561326cff8a7cb711980b59dc8d25ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads array of byte data from the specified address.  <a href="#ga8561326cff8a7cb711980b59dc8d25ae">More...</a><br /></td></tr>
<tr class="separator:ga8561326cff8a7cb711980b59dc8d25ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9450354bd476e472b763b3e7244f0ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga9450354bd476e472b763b3e7244f0ae6">Cy_RRAM_NonBlockingNvmWriteByteArray</a> (RRAMC_Type *base, uint32_t addr, const uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga9450354bd476e472b763b3e7244f0ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes array of byte data to the specified address in Non Blocking mode.  <a href="#ga9450354bd476e472b763b3e7244f0ae6">More...</a><br /></td></tr>
<tr class="separator:ga9450354bd476e472b763b3e7244f0ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed130882cf36ff3fe5a80f27934abec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga3ed130882cf36ff3fe5a80f27934abec">Cy_RRAM_NvmWriteBlock</a> (RRAMC_Type *base, uint32_t addr, uint8_t *data)</td></tr>
<tr class="memdesc:ga3ed130882cf36ff3fe5a80f27934abec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a block(16B) data to the specified address.  <a href="#ga3ed130882cf36ff3fe5a80f27934abec">More...</a><br /></td></tr>
<tr class="separator:ga3ed130882cf36ff3fe5a80f27934abec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496307636e7a6504de30ca3679ef983a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga496307636e7a6504de30ca3679ef983a">Cy_RRAM_WriteByteArray</a> (RRAMC_Type *base, uint32_t addr, const uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga496307636e7a6504de30ca3679ef983a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes array of byte data to the specified address in blocking mode.  <a href="#ga496307636e7a6504de30ca3679ef983a">More...</a><br /></td></tr>
<tr class="separator:ga496307636e7a6504de30ca3679ef983a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb124a09514ef4682c5baf51b174252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#gabbb124a09514ef4682c5baf51b174252">Cy_RRAM_TSWriteByteArray</a> (RRAMC_Type *base, uint32_t addr, const uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:gabbb124a09514ef4682c5baf51b174252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of byte data to the specified address in blocking mode without considering uncorrectable ECC fail error.  <a href="#gabbb124a09514ef4682c5baf51b174252">More...</a><br /></td></tr>
<tr class="separator:gabbb124a09514ef4682c5baf51b174252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f7425e05efe4bcca9f60e4b1270a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga46f7425e05efe4bcca9f60e4b1270a2c">Cy_RRAM_ReadByteArray</a> (RRAMC_Type *base, uint32_t addr, uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga46f7425e05efe4bcca9f60e4b1270a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of byte data from the specified address.  <a href="#ga46f7425e05efe4bcca9f60e4b1270a2c">More...</a><br /></td></tr>
<tr class="separator:ga46f7425e05efe4bcca9f60e4b1270a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab83a5d1d995a7202bb60108220fc4a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#gab83a5d1d995a7202bb60108220fc4a7b">Cy_RRAM_TSReadByteArray</a> (RRAMC_Type *base, uint32_t addr, uint8_t *data, uint32_t numBytes)</td></tr>
<tr class="memdesc:gab83a5d1d995a7202bb60108220fc4a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of byte data from the specified address after validating the uncorrectable ECC fail bits.  <a href="#gab83a5d1d995a7202bb60108220fc4a7b">More...</a><br /></td></tr>
<tr class="separator:gab83a5d1d995a7202bb60108220fc4a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3208ac6bc03444c7c745d9732c43bfa1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga3208ac6bc03444c7c745d9732c43bfa1">Cy_RRAM_GetStatus</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga3208ac6bc03444c7c745d9732c43bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of RRAM.  <a href="#ga3208ac6bc03444c7c745d9732c43bfa1">More...</a><br /></td></tr>
<tr class="separator:ga3208ac6bc03444c7c745d9732c43bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdaa2e260da5c0623f5ef257103d439f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga855ac505e4b109c962b3088b9bfbe87e">cy_en_rram_hresp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:gacdaa2e260da5c0623f5ef257103d439f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets AHB bus error occurred during transactions.  <a href="#gacdaa2e260da5c0623f5ef257103d439f">More...</a><br /></td></tr>
<tr class="separator:gacdaa2e260da5c0623f5ef257103d439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96bf778ebae9706a4da6098fb0bbe2b6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga96bf778ebae9706a4da6098fb0bbe2b6">Cy_RRAM_EnableSleepMode</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga96bf778ebae9706a4da6098fb0bbe2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts RRAM in Sleep mode.  <a href="#ga96bf778ebae9706a4da6098fb0bbe2b6">More...</a><br /></td></tr>
<tr class="separator:ga96bf778ebae9706a4da6098fb0bbe2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90b47ae581209e4ee9a6c5ff1ef0f16"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#gaf90b47ae581209e4ee9a6c5ff1ef0f16">Cy_RRAM_DisableSleepMode</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:gaf90b47ae581209e4ee9a6c5ff1ef0f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts RRAM in Normal mode.  <a href="#gaf90b47ae581209e4ee9a6c5ff1ef0f16">More...</a><br /></td></tr>
<tr class="separator:gaf90b47ae581209e4ee9a6c5ff1ef0f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787a0bb30969e36aac90da7830682b88"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga8c5aee435bae11760144bb034fca364c">cy_en_rram_sleep_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga787a0bb30969e36aac90da7830682b88">Cy_RRAM_GetSleepStatus</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga787a0bb30969e36aac90da7830682b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sleep status of RRAM.  <a href="#ga787a0bb30969e36aac90da7830682b88">More...</a><br /></td></tr>
<tr class="separator:ga787a0bb30969e36aac90da7830682b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7528e68b89a4ad449dd3ba96fdf3c569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga7528e68b89a4ad449dd3ba96fdf3c569">Cy_RRAM_EnableWP</a> (RRAMC_Type *base, uint32_t numSectors)</td></tr>
<tr class="memdesc:ga7528e68b89a4ad449dd3ba96fdf3c569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables write protection for number of sectors starting with sector 0 in RRAM NVM region.  <a href="#ga7528e68b89a4ad449dd3ba96fdf3c569">More...</a><br /></td></tr>
<tr class="separator:ga7528e68b89a4ad449dd3ba96fdf3c569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d529a42ba086a9e3bc48d46eec40d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga9d529a42ba086a9e3bc48d46eec40d82">Cy_RRAM_DisableWP</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga9d529a42ba086a9e3bc48d46eec40d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write protection for all sectors in RRAM NVM region.  <a href="#ga9d529a42ba086a9e3bc48d46eec40d82">More...</a><br /></td></tr>
<tr class="separator:ga9d529a42ba086a9e3bc48d46eec40d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7a46befa52f9d9e3b32ae46bbf142e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga2c7a46befa52f9d9e3b32ae46bbf142e">Cy_RRAM_SetWPLock</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga2c7a46befa52f9d9e3b32ae46bbf142e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the write protection lock by setting WPCLK to 1.  <a href="#ga2c7a46befa52f9d9e3b32ae46bbf142e">More...</a><br /></td></tr>
<tr class="separator:ga2c7a46befa52f9d9e3b32ae46bbf142e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fbdfbdd9592436f2b1a49bdd49a8f34"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#gabea8f3c5ded32e989b6d69826b9cf41a">cy_en_rram_wp_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34">Cy_RRAM_GetWPLockState</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga9fbdfbdd9592436f2b1a49bdd49a8f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of write protection lock.  <a href="#ga9fbdfbdd9592436f2b1a49bdd49a8f34">More...</a><br /></td></tr>
<tr class="separator:ga9fbdfbdd9592436f2b1a49bdd49a8f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbc23cc2062a2059b790c128ddc8409"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga2cbc23cc2062a2059b790c128ddc8409">Cy_RRAM_SetVoltageMode</a> (RRAMC_Type *base, <a class="el" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a> vmode)</td></tr>
<tr class="memdesc:ga2cbc23cc2062a2059b790c128ddc8409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set voltage/frequency mode.  <a href="#ga2cbc23cc2062a2059b790c128ddc8409">More...</a><br /></td></tr>
<tr class="separator:ga2cbc23cc2062a2059b790c128ddc8409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2618b5aea210c4b19977c29bd799e7bd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga2618b5aea210c4b19977c29bd799e7bd">Cy_RRAM_GetVoltageMode</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga2618b5aea210c4b19977c29bd799e7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get voltage/frequency mode.  <a href="#ga2618b5aea210c4b19977c29bd799e7bd">More...</a><br /></td></tr>
<tr class="separator:ga2618b5aea210c4b19977c29bd799e7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1a11952ba013fd1f5fa0f1cbcd6cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">Cy_RRAM_SetProtLockableRegion</a> (RRAMC_Type *base, uint32_t regionSize)</td></tr>
<tr class="memdesc:ga9e1a11952ba013fd1f5fa0f1cbcd6cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of lockable region in PROTECTED_NVM region.  <a href="#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">More...</a><br /></td></tr>
<tr class="separator:ga9e1a11952ba013fd1f5fa0f1cbcd6cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78b51e121f0f53673a3bccf174fe4eb0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga78b51e121f0f53673a3bccf174fe4eb0">Cy_RRAM_GetProtLockableRegion</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga78b51e121f0f53673a3bccf174fe4eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of configured lockable region in PROTECTED_NVM region.  <a href="#ga78b51e121f0f53673a3bccf174fe4eb0">More...</a><br /></td></tr>
<tr class="separator:ga78b51e121f0f53673a3bccf174fe4eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171fd1c80e4656c1593d47f75c9423d8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga171fd1c80e4656c1593d47f75c9423d8">Cy_RRAM_SetProtLock</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga171fd1c80e4656c1593d47f75c9423d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the lock for the configured PROTECTED_NVM region <a class="el" href="group__group__rram__functions.html#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">Cy_RRAM_SetProtLockableRegion()</a>.  <a href="#ga171fd1c80e4656c1593d47f75c9423d8">More...</a><br /></td></tr>
<tr class="separator:ga171fd1c80e4656c1593d47f75c9423d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b93da74d4779f1207a722271c0e64f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga2cd8e600602141f32af6d4bb707175fd">cy_en_rram_protected_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga54b93da74d4779f1207a722271c0e64f">Cy_RRAM_GetProtLockState</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga54b93da74d4779f1207a722271c0e64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lock state of the PROTECTED_NVM Lockable region.  <a href="#ga54b93da74d4779f1207a722271c0e64f">More...</a><br /></td></tr>
<tr class="separator:ga54b93da74d4779f1207a722271c0e64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4ffac792856fb5ed9f2638af117b95"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga2d4ffac792856fb5ed9f2638af117b95">Cy_RRAM_SetUDSLock</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga2d4ffac792856fb5ed9f2638af117b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the lock to avoid access to UDS key.  <a href="#ga2d4ffac792856fb5ed9f2638af117b95">More...</a><br /></td></tr>
<tr class="separator:ga2d4ffac792856fb5ed9f2638af117b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da4812551d55a196b6f54152728dc42"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga8ca3563334bdd5f808c929837f4e107e">cy_en_rram_uds_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga8da4812551d55a196b6f54152728dc42">Cy_RRAM_GetUDSLockState</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga8da4812551d55a196b6f54152728dc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of UDS lock.  <a href="#ga8da4812551d55a196b6f54152728dc42">More...</a><br /></td></tr>
<tr class="separator:ga8da4812551d55a196b6f54152728dc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd175a5ed35ca43b6ac2c8a6027a3ab"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga2bd175a5ed35ca43b6ac2c8a6027a3ab">Cy_RRAM_SetUDSConfig</a> (RRAMC_Type *base, bool config)</td></tr>
<tr class="memdesc:ga2bd175a5ed35ca43b6ac2c8a6027a3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure UDS to trigger a AHB error or read as zero without error when there is a read access to UDS.  <a href="#ga2bd175a5ed35ca43b6ac2c8a6027a3ab">More...</a><br /></td></tr>
<tr class="separator:ga2bd175a5ed35ca43b6ac2c8a6027a3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3af8c8d7c2b521eb53f5ef47e3f88b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__rram__functions.html#ga5b3af8c8d7c2b521eb53f5ef47e3f88b">Cy_RRAM_ForceRelPCLock</a> (RRAMC_Type *base)</td></tr>
<tr class="memdesc:ga5b3af8c8d7c2b521eb53f5ef47e3f88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release PC lock forcefully.  <a href="#ga5b3af8c8d7c2b521eb53f5ef47e3f88b">More...</a><br /></td></tr>
<tr class="separator:ga5b3af8c8d7c2b521eb53f5ef47e3f88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab63a4b927a0745e0342b0de9c8c46482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab63a4b927a0745e0342b0de9c8c46482">&#9670;&nbsp;</a></span>Cy_RRAM_OtpWriteByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_OtpWriteByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes array of byte data to the specified address. </p>
<p>This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the OTP subsection. The address should fall in General OTP or Protected OTP subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written to the specified address.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_PROTECTED_OTP_PROTECTED_S_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U] = {0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U, 0x08U};</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes array of byte to the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#gab63a4b927a0745e0342b0de9c8c46482">Cy_RRAM_OtpWriteByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>OTP region is One Time Programmable. API does read-modify(OR)-write operation.</dd></dl>
<p>The address should fall in General OTP or Protected OTP subsection. </p>

</div>
</div>
<a id="gaccc1c7abb8466ba7f5643bfdcdd495bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccc1c7abb8466ba7f5643bfdcdd495bb">&#9670;&nbsp;</a></span>Cy_RRAM_OtpReadByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_OtpReadByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads array of byte data from the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the OTP subsection. The address should fall in General OTP or Protected OTP subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the destination where the read data is stored.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_GENERAL_OTP_MMIO_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    uint8_t data[numBytes];</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reads array of byte data from the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#gaccc1c7abb8466ba7f5643bfdcdd495bb">Cy_RRAM_OtpReadByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> The address should fall in General OTP or Protected OTP subsection. </dd></dl>

</div>
</div>
<a id="ga590fa451d221ea4f1027bfc549b024ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga590fa451d221ea4f1027bfc549b024ae">&#9670;&nbsp;</a></span>Cy_RRAM_OtpWriteWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_OtpWriteWord </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 32-bit word data to the specified address. </p>
<p>This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the OTP subsection. The address should fall in General OTP or Protected OTP subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Data to be written to the specified address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_PROTECTED_OTP_PROTECTED_S_START_ADDRESS + 0x12UL;</div><div class="line">    uint32_t data = 0x01020304UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes a 32-bit word data to the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga590fa451d221ea4f1027bfc549b024ae">Cy_RRAM_OtpWriteWord</a>(base, addr, data);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>OTP region is One Time Programmable. API does read-modify(OR)-write operation.</dd></dl>
<p>The address should fall in General OTP or Protected OTP subsection. </p>

</div>
</div>
<a id="gaed7b3b7eef4f26a45fafd4962ded3395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7b3b7eef4f26a45fafd4962ded3395">&#9670;&nbsp;</a></span>Cy_RRAM_OtpReadWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_OtpReadWord </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32bit word data from the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the OTP subsection. The address should fall in General OTP or Protected OTP subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the destination where the read word is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_GENERAL_OTP_MMIO_S_START_ADDRESS + 0x12UL;</div><div class="line">    uint32_t data;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reads a word data from the specified address.*/</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status =  <a class="code" href="group__group__rram__functions.html#gaed7b3b7eef4f26a45fafd4962ded3395">Cy_RRAM_OtpReadWord</a>(base, addr, &amp;data);</div><div class="line"></div></div><!-- fragment --> The address should fall in General OTP or Protected OTP subsection. </dd></dl>

</div>
</div>
<a id="ga7c7dbd1a2bf852a5652771b40048f15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c7dbd1a2bf852a5652771b40048f15c">&#9670;&nbsp;</a></span>Cy_RRAM_OtpWriteBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_OtpWriteBlock </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a block(16B) data to the specified address. </p>
<p>Assumption is that the provided address is block aligned. This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the OTP subsection. The address should fall in General OTP or Protected OTP subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written to the specified address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_PROTECTED_OTP_PROTECTED_S_START_ADDRESS;</div><div class="line">    uint8_t data[CY_RRAM_BLOCK_SIZE_BYTES];</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;CY_RRAM_BLOCK_SIZE_BYTES; i++)</div><div class="line">    {</div><div class="line">        data[i] = i+1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes a 16B block data to the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga7c7dbd1a2bf852a5652771b40048f15c">Cy_RRAM_OtpWriteBlock</a>(base, addr, data);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>OTP region is One Time Programmable. API does read-modify(OR)-write operation.</dd></dl>
<p>The address should be block aligned. The address should fall in General OTP or Protected OTP subsection. </p>

</div>
</div>
<a id="ga7e80ece896f80a3eb042d1d7b7b2bb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e80ece896f80a3eb042d1d7b7b2bb1d">&#9670;&nbsp;</a></span>Cy_RRAM_NvmWriteByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_NvmWriteByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes array of byte data to the specified address in blocking mode. </p>
<p>API will wait for the write operation to be completed. It returns error or success status. This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the NVM subsection. The address should fall in Main or Work or Sflash or Protected NVM subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written to the specified address.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U] = {0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U, 0x08U};</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes array of byte to the specified address in Blocking mode. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> The address should fall in Main or Work or Sflash or Protected NVM subsection. </dd></dl>

</div>
</div>
<a id="ga8561326cff8a7cb711980b59dc8d25ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8561326cff8a7cb711980b59dc8d25ae">&#9670;&nbsp;</a></span>Cy_RRAM_NvmReadByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_NvmReadByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads array of byte data from the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the NVM subsection. The address should fall in Main or Work or Sflash or Protected NVM subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the destination where the read data is stored.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    uint8_t data[numBytes];</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reads array of byte data from the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> The address should fall in Main, Work, Sflash, Protected NVM subsection. </dd></dl>

</div>
</div>
<a id="ga9450354bd476e472b763b3e7244f0ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9450354bd476e472b763b3e7244f0ae6">&#9670;&nbsp;</a></span>Cy_RRAM_NonBlockingNvmWriteByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_NonBlockingNvmWriteByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes array of byte data to the specified address in Non Blocking mode. </p>
<p>API will only validate parameter and performs write operation. User needs to call <a class="el" href="group__group__rram__functions.html#ga3208ac6bc03444c7c745d9732c43bfa1">Cy_RRAM_GetStatus()</a> to check the status of write operation. This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the NVM subsection. The address should fall in Main or Work or Sflash or Protected NVM subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written to the specified address.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U] = {0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U, 0x08U};</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes array of byte to the specified address in Non-Blocking mode. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga9450354bd476e472b763b3e7244f0ae6">Cy_RRAM_NonBlockingNvmWriteByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div><div class="line">    <span class="comment">/* Check the error status for the non-blocking mode */</span></div><div class="line">    uint32_t errorStatus = <a class="code" href="group__group__rram__functions.html#ga3208ac6bc03444c7c745d9732c43bfa1">Cy_RRAM_GetStatus</a>(base);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga855ac505e4b109c962b3088b9bfbe87e">cy_en_rram_hresp_t</a> ahbError = <a class="code" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a>(base);</div><div class="line"></div></div><!-- fragment --> The address should fall in Main or Work or Sflash or Protected NVM subsection. </dd></dl>

</div>
</div>
<a id="ga3ed130882cf36ff3fe5a80f27934abec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed130882cf36ff3fe5a80f27934abec">&#9670;&nbsp;</a></span>Cy_RRAM_NvmWriteBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_NvmWriteBlock </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a block(16B) data to the specified address. </p>
<p>Assumption is that the provided address is Block aligned. This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the NVM subsection. The address should fall in Main or Work or Sflash or Protected NVM subsection.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written to the specified address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS;</div><div class="line">    uint8_t data[CY_RRAM_BLOCK_SIZE_BYTES];</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;CY_RRAM_BLOCK_SIZE_BYTES; i++)</div><div class="line">    {</div><div class="line">        data[i] = i+1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes a 16B block data to the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga7c7dbd1a2bf852a5652771b40048f15c">Cy_RRAM_OtpWriteBlock</a>(base, addr, data);</div><div class="line"></div></div><!-- fragment --> Writes a block(16B) data to the specified address.</dd></dl>
<p>The address should fall in Main or Work or Sflash or Protected NVM subsection. </p>

</div>
</div>
<a id="ga496307636e7a6504de30ca3679ef983a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga496307636e7a6504de30ca3679ef983a">&#9670;&nbsp;</a></span>Cy_RRAM_WriteByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_WriteByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes array of byte data to the specified address in blocking mode. </p>
<p>API will wait for the write operation to be completed. It returns error or success status. This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of RRAM memory. The provided address should fall under one of the NVM or OTP sub sections otherwise bad parameter error will be returned.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written to the specified address.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U] = {0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U, 0x08U};</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes array of byte data to the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga496307636e7a6504de30ca3679ef983a">Cy_RRAM_WriteByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>OTP region is One Time Programmable. API does read-modify(OR)-write operation.</dd></dl>
<p>Writes array of byte data to the specified address in blocking mode.</p>
<p>API will wait for the write operation to be completed. It returns error or success status. </p>

</div>
</div>
<a id="gabbb124a09514ef4682c5baf51b174252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbb124a09514ef4682c5baf51b174252">&#9670;&nbsp;</a></span>Cy_RRAM_TSWriteByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_TSWriteByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of byte data to the specified address in blocking mode without considering uncorrectable ECC fail error. </p>
<p>API will wait for the write operation to be completed. It returns error or success status. This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of RRAM memory. The provided address should fall under one of the NVM or OTP sub sections otherwise bad parameter error will be returned.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written to the specified address.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U] = {0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U, 0x08U};</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes array of byte data to the specified address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#gabbb124a09514ef4682c5baf51b174252">Cy_RRAM_TSWriteByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API should be used only for tearing safe use cases.</dd></dl>
<p>This API should be used only for tearing safe use cases. </p>

</div>
</div>
<a id="ga46f7425e05efe4bcca9f60e4b1270a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f7425e05efe4bcca9f60e4b1270a2c">&#9670;&nbsp;</a></span>Cy_RRAM_ReadByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_ReadByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of byte data from the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of RRAM memory. The provided address should fall under one of the NVM or OTP sub sections otherwise bad parameter error will be returned.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the destination where the read data is stored.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U];</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reads a array of byte data from the address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga46f7425e05efe4bcca9f60e4b1270a2c">Cy_RRAM_ReadByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> Reads an array of byte data from the specified address. </dd></dl>

</div>
</div>
<a id="gab83a5d1d995a7202bb60108220fc4a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab83a5d1d995a7202bb60108220fc4a7b">&#9670;&nbsp;</a></span>Cy_RRAM_TSReadByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_TSReadByteArray </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of byte data from the specified address after validating the uncorrectable ECC fail bits. </p>
<p>Returns ECC fail error if uncorrectable ECC fail error exist. This function tries to acquire the lock. If the lock is not available, then it returns immediately with CY_RRAM_ACQUIRE_PC_LOCK_FAIL error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">addr</td><td>Address of RRAM memory. The provided address should fall under one of the NVM or OTP sub sections otherwise bad parameter error will be returned.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the destination where the read data is stored.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U];</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reads a array of byte data from the address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga46f7425e05efe4bcca9f60e4b1270a2c">Cy_RRAM_ReadByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U];</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reads a array of byte data from the address. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#gab83a5d1d995a7202bb60108220fc4a7b">Cy_RRAM_TSReadByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API should be used only for tearing safe use cases.</dd></dl>
<p>Returns ECC fail error if uncorrectable ECC fail error exist. This API should be used only for tearing safe use cases. </p>

</div>
</div>
<a id="ga3208ac6bc03444c7c745d9732c43bfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3208ac6bc03444c7c745d9732c43bfa1">&#9670;&nbsp;</a></span>Cy_RRAM_GetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_RRAM_GetStatus </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of RRAM. </p>
<p>It includes information about busy status, sleep status, status on ECC during read operation, write protection error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RRAM status.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U] = {0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U, 0x08U};</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes array of byte to the specified address in Non-Blocking mode. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga9450354bd476e472b763b3e7244f0ae6">Cy_RRAM_NonBlockingNvmWriteByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div><div class="line">    <span class="comment">/* Check the error status for the non-blocking mode */</span></div><div class="line">    uint32_t errorStatus = <a class="code" href="group__group__rram__functions.html#ga3208ac6bc03444c7c745d9732c43bfa1">Cy_RRAM_GetStatus</a>(base);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga855ac505e4b109c962b3088b9bfbe87e">cy_en_rram_hresp_t</a> ahbError = <a class="code" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a>(base);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gacdaa2e260da5c0623f5ef257103d439f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdaa2e260da5c0623f5ef257103d439f">&#9670;&nbsp;</a></span>Cy_RRAM_GetAHBError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga855ac505e4b109c962b3088b9bfbe87e">cy_en_rram_hresp_t</a> Cy_RRAM_GetAHBError </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets AHB bus error occurred during transactions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#ga855ac505e4b109c962b3088b9bfbe87e">cy_en_rram_hresp_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_NS_START_ADDRESS + 0x12UL;</div><div class="line">    uint8_t data[8U] = {0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x06U, 0x07U, 0x08U};</div><div class="line">    uint32_t numBytes = 8UL;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Writes array of byte to the specified address in Non-Blocking mode. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__functions.html#ga9450354bd476e472b763b3e7244f0ae6">Cy_RRAM_NonBlockingNvmWriteByteArray</a>(base, addr, data, numBytes);</div><div class="line"></div><div class="line">    <span class="comment">/* Check the error status for the non-blocking mode */</span></div><div class="line">    uint32_t errorStatus = <a class="code" href="group__group__rram__functions.html#ga3208ac6bc03444c7c745d9732c43bfa1">Cy_RRAM_GetStatus</a>(base);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga855ac505e4b109c962b3088b9bfbe87e">cy_en_rram_hresp_t</a> ahbError = <a class="code" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a>(base);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga96bf778ebae9706a4da6098fb0bbe2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96bf778ebae9706a4da6098fb0bbe2b6">&#9670;&nbsp;</a></span>Cy_RRAM_EnableSleepMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_EnableSleepMode </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts RRAM in Sleep mode. </p>
<p>No memory access is possible in NVM sleep mode. During sleep, the SFR NVM_CONF1 can be read and written, all other SFRs are read-only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario:  Enable/Disable RRAM sleep mode. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga8c5aee435bae11760144bb034fca364c">cy_en_rram_sleep_t</a> status = <a class="code" href="group__group__rram__functions.html#ga787a0bb30969e36aac90da7830682b88">Cy_RRAM_GetSleepStatus</a>(base);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#gga8c5aee435bae11760144bb034fca364cab858fbfc564ea3b117e1453fb0502540">CY_RRAM_NOT_IN_SLEEP</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__rram__functions.html#ga96bf778ebae9706a4da6098fb0bbe2b6">Cy_RRAM_EnableSleepMode</a>(base);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#gga8c5aee435bae11760144bb034fca364ca9b5efa6eeb503ee6c6a76babdb4a1ca1">CY_RRAM_IN_SLEEP</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__rram__functions.html#gaf90b47ae581209e4ee9a6c5ff1ef0f16">Cy_RRAM_DisableSleepMode</a>(base);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaf90b47ae581209e4ee9a6c5ff1ef0f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90b47ae581209e4ee9a6c5ff1ef0f16">&#9670;&nbsp;</a></span>Cy_RRAM_DisableSleepMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_DisableSleepMode </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts RRAM in Normal mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario:  Enable/Disable RRAM sleep mode. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga8c5aee435bae11760144bb034fca364c">cy_en_rram_sleep_t</a> status = <a class="code" href="group__group__rram__functions.html#ga787a0bb30969e36aac90da7830682b88">Cy_RRAM_GetSleepStatus</a>(base);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#gga8c5aee435bae11760144bb034fca364cab858fbfc564ea3b117e1453fb0502540">CY_RRAM_NOT_IN_SLEEP</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__rram__functions.html#ga96bf778ebae9706a4da6098fb0bbe2b6">Cy_RRAM_EnableSleepMode</a>(base);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#gga8c5aee435bae11760144bb034fca364ca9b5efa6eeb503ee6c6a76babdb4a1ca1">CY_RRAM_IN_SLEEP</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__rram__functions.html#gaf90b47ae581209e4ee9a6c5ff1ef0f16">Cy_RRAM_DisableSleepMode</a>(base);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga787a0bb30969e36aac90da7830682b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga787a0bb30969e36aac90da7830682b88">&#9670;&nbsp;</a></span>Cy_RRAM_GetSleepStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga8c5aee435bae11760144bb034fca364c">cy_en_rram_sleep_t</a> Cy_RRAM_GetSleepStatus </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sleep status of RRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#ga8c5aee435bae11760144bb034fca364c">cy_en_rram_sleep_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario:  Enable/Disable RRAM sleep mode. */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga8c5aee435bae11760144bb034fca364c">cy_en_rram_sleep_t</a> status = <a class="code" href="group__group__rram__functions.html#ga787a0bb30969e36aac90da7830682b88">Cy_RRAM_GetSleepStatus</a>(base);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#gga8c5aee435bae11760144bb034fca364cab858fbfc564ea3b117e1453fb0502540">CY_RRAM_NOT_IN_SLEEP</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__rram__functions.html#ga96bf778ebae9706a4da6098fb0bbe2b6">Cy_RRAM_EnableSleepMode</a>(base);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#gga8c5aee435bae11760144bb034fca364ca9b5efa6eeb503ee6c6a76babdb4a1ca1">CY_RRAM_IN_SLEEP</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__rram__functions.html#gaf90b47ae581209e4ee9a6c5ff1ef0f16">Cy_RRAM_DisableSleepMode</a>(base);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7528e68b89a4ad449dd3ba96fdf3c569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7528e68b89a4ad449dd3ba96fdf3c569">&#9670;&nbsp;</a></span>Cy_RRAM_EnableWP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_EnableWP </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables write protection for number of sectors starting with sector 0 in RRAM NVM region. </p>
<p>Before calling this API, user need to call <a class="el" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34" title="Gets the state of write protection lock. ">Cy_RRAM_GetWPLockState()</a> API and make sure the write protection lock is not locked. Otherwise this API will return CY_RRAM_WPLOCK_ENABLED error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">numSectors</td><td>Number of sectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Number of sectors to be write protected. */</span></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_S_START_ADDRESS;</div><div class="line">    uint32_t numSectors = 4UL;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a43f47d4c469ae8dffc1c996e23eeb566">CY_RRAM_WPLOCK_ENABLED</a>;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line">    uint8_t readData[numBytes];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Enable Write Protection for NVM sectors. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34">Cy_RRAM_GetWPLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#ggabea8f3c5ded32e989b6d69826b9cf41aa5b2820291ed256d554acbaad200d1a42">CY_RRAM_WP_UNLOCK</a>)</div><div class="line">    {</div><div class="line">       status  = <a class="code" href="group__group__rram__functions.html#ga7528e68b89a4ad449dd3ba96fdf3c569">Cy_RRAM_EnableWP</a>(base, numSectors);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the write protected memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should not match</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Disable Write Protection for NVM sectors. */</span></div><div class="line">    status  = <a class="code" href="group__group__rram__functions.html#ga9d529a42ba086a9e3bc48d46eec40d82">Cy_RRAM_DisableWP</a>(base);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should match, since there is no write protection</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> Before calling this API, user need to call <a class="el" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34" title="Gets the state of write protection lock. ">Cy_RRAM_GetWPLockState()</a> API and make sure the write protection lock is not locked. Otherwise this API will return CY_RRAM_WPLOCK_ENABLED error. </dd></dl>

</div>
</div>
<a id="ga9d529a42ba086a9e3bc48d46eec40d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d529a42ba086a9e3bc48d46eec40d82">&#9670;&nbsp;</a></span>Cy_RRAM_DisableWP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_DisableWP </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables write protection for all sectors in RRAM NVM region. </p>
<p>Before calling this API, user need to call <a class="el" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34" title="Gets the state of write protection lock. ">Cy_RRAM_GetWPLockState()</a> API and make sure the write protection lock is not locked. Otherwise this API will return CY_RRAM_WPLOCK_ENABLED error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Number of sectors to be write protected. */</span></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_S_START_ADDRESS;</div><div class="line">    uint32_t numSectors = 4UL;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a43f47d4c469ae8dffc1c996e23eeb566">CY_RRAM_WPLOCK_ENABLED</a>;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line">    uint8_t readData[numBytes];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Enable Write Protection for NVM sectors. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34">Cy_RRAM_GetWPLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#ggabea8f3c5ded32e989b6d69826b9cf41aa5b2820291ed256d554acbaad200d1a42">CY_RRAM_WP_UNLOCK</a>)</div><div class="line">    {</div><div class="line">       status  = <a class="code" href="group__group__rram__functions.html#ga7528e68b89a4ad449dd3ba96fdf3c569">Cy_RRAM_EnableWP</a>(base, numSectors);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the write protected memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should not match</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Disable Write Protection for NVM sectors. */</span></div><div class="line">    status  = <a class="code" href="group__group__rram__functions.html#ga9d529a42ba086a9e3bc48d46eec40d82">Cy_RRAM_DisableWP</a>(base);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should match, since there is no write protection</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> Before calling this API, user need to call <a class="el" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34" title="Gets the state of write protection lock. ">Cy_RRAM_GetWPLockState()</a> API and make sure the write protection lock is not locked. Otherwise this API will return CY_RRAM_WPLOCK_ENABLED error. </dd></dl>

</div>
</div>
<a id="ga2c7a46befa52f9d9e3b32ae46bbf142e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c7a46befa52f9d9e3b32ae46bbf142e">&#9670;&nbsp;</a></span>Cy_RRAM_SetWPLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_SetWPLock </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the write protection lock by setting WPCLK to 1. </p>
<p>Once locked, the lock state cannot be changed till next reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Number of sectors to be write protected. */</span></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_S_START_ADDRESS;</div><div class="line">    uint32_t numSectors = 4UL;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a43f47d4c469ae8dffc1c996e23eeb566">CY_RRAM_WPLOCK_ENABLED</a>;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line">    uint8_t readData[numBytes];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Enable Write Protection for NVM sectors. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34">Cy_RRAM_GetWPLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#ggabea8f3c5ded32e989b6d69826b9cf41aa5b2820291ed256d554acbaad200d1a42">CY_RRAM_WP_UNLOCK</a>)</div><div class="line">    {</div><div class="line">       status  = <a class="code" href="group__group__rram__functions.html#ga7528e68b89a4ad449dd3ba96fdf3c569">Cy_RRAM_EnableWP</a>(base, numSectors);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the write protected memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should not match</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Disable Write Protection for NVM sectors. */</span></div><div class="line">    status  = <a class="code" href="group__group__rram__functions.html#ga9d529a42ba086a9e3bc48d46eec40d82">Cy_RRAM_DisableWP</a>(base);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should match, since there is no write protection</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga9fbdfbdd9592436f2b1a49bdd49a8f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fbdfbdd9592436f2b1a49bdd49a8f34">&#9670;&nbsp;</a></span>Cy_RRAM_GetWPLockState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#gabea8f3c5ded32e989b6d69826b9cf41a">cy_en_rram_wp_lock_t</a> Cy_RRAM_GetWPLockState </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state of write protection lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gabea8f3c5ded32e989b6d69826b9cf41a">cy_en_rram_wp_lock_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Number of sectors to be write protected. */</span></div><div class="line">    uint32_t addr = CY_RRAM_MAIN_HOST_S_START_ADDRESS;</div><div class="line">    uint32_t numSectors = 4UL;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a43f47d4c469ae8dffc1c996e23eeb566">CY_RRAM_WPLOCK_ENABLED</a>;</div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line">    uint8_t readData[numBytes];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Enable Write Protection for NVM sectors. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga9fbdfbdd9592436f2b1a49bdd49a8f34">Cy_RRAM_GetWPLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#ggabea8f3c5ded32e989b6d69826b9cf41aa5b2820291ed256d554acbaad200d1a42">CY_RRAM_WP_UNLOCK</a>)</div><div class="line">    {</div><div class="line">       status  = <a class="code" href="group__group__rram__functions.html#ga7528e68b89a4ad449dd3ba96fdf3c569">Cy_RRAM_EnableWP</a>(base, numSectors);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the write protected memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should not match</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Disable Write Protection for NVM sectors. */</span></div><div class="line">    status  = <a class="code" href="group__group__rram__functions.html#ga9d529a42ba086a9e3bc48d46eec40d82">Cy_RRAM_DisableWP</a>(base);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Perform write operation on the memory.</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">// Read back the written data</span></div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga8561326cff8a7cb711980b59dc8d25ae">Cy_RRAM_NvmReadByteArray</a>(base, addr, readData, numBytes);</div><div class="line"></div><div class="line">        <span class="comment">//Read and written data should match, since there is no write protection</span></div><div class="line">        <span class="keywordflow">if</span>(memcmp(&amp;writeData, &amp;readData, <span class="keyword">sizeof</span>(writeData)) == 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Test case success.</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Test case failed.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2cbc23cc2062a2059b790c128ddc8409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbc23cc2062a2059b790c128ddc8409">&#9670;&nbsp;</a></span>Cy_RRAM_SetVoltageMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_SetVoltageMode </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a>&#160;</td>
          <td class="paramname"><em>vmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set voltage/frequency mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">vmode</td><td>Voltage mode. Refer <a class="el" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario:  Update voltage/frequency mode. */</span></div><div class="line">    <span class="comment">/* Get the current mode */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a> <a class="code" href="group__group__ipc__bt__data__structures.html#ga37e90f5e3bd99fac2021fb3a326607d4">mode</a> = <a class="code" href="group__group__rram__functions.html#ga2618b5aea210c4b19977c29bd799e7bd">Cy_RRAM_GetVoltageMode</a>(RRAMC0);</div><div class="line"></div><div class="line">    <span class="comment">/* Set mode to undefined */</span></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2cbc23cc2062a2059b790c128ddc8409">Cy_RRAM_SetVoltageMode</a>(base, <a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a7fd97cbcf03d5c504401695619adfcff">CY_RRAM_VMODE_UNDEFINED</a>);</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a7fd97cbcf03d5c504401695619adfcff">CY_RRAM_VMODE_UNDEFINED</a> == <a class="code" href="group__group__rram__functions.html#ga2618b5aea210c4b19977c29bd799e7bd">Cy_RRAM_GetVoltageMode</a>(base))</div><div class="line">    {</div><div class="line">        <span class="comment">// Updated to undefined mode</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set mode to MF */</span></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2cbc23cc2062a2059b790c128ddc8409">Cy_RRAM_SetVoltageMode</a>(base, <a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a13d8ef9a8080eb12a60f524ddd6bccf1">CY_RRAM_VMODE_HP</a>);</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a13d8ef9a8080eb12a60f524ddd6bccf1">CY_RRAM_VMODE_HP</a> == <a class="code" href="group__group__rram__functions.html#ga2618b5aea210c4b19977c29bd799e7bd">Cy_RRAM_GetVoltageMode</a>(base))</div><div class="line">    {</div><div class="line">        <span class="comment">//Updated to MF mode</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">//Failed to update to MF mode</span></div><div class="line">    }</div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2cbc23cc2062a2059b790c128ddc8409">Cy_RRAM_SetVoltageMode</a>(base, mode);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2618b5aea210c4b19977c29bd799e7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2618b5aea210c4b19977c29bd799e7bd">&#9670;&nbsp;</a></span>Cy_RRAM_GetVoltageMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a> Cy_RRAM_GetVoltageMode </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get voltage/frequency mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Voltage mode. Refer <a class="el" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario:  Update voltage/frequency mode. */</span></div><div class="line">    <span class="comment">/* Get the current mode */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#gab670347c8e2e397a1b9fd82b6f31c002">cy_en_rram_vmode_t</a> mode = <a class="code" href="group__group__rram__functions.html#ga2618b5aea210c4b19977c29bd799e7bd">Cy_RRAM_GetVoltageMode</a>(RRAMC0);</div><div class="line"></div><div class="line">    <span class="comment">/* Set mode to undefined */</span></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2cbc23cc2062a2059b790c128ddc8409">Cy_RRAM_SetVoltageMode</a>(base, <a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a7fd97cbcf03d5c504401695619adfcff">CY_RRAM_VMODE_UNDEFINED</a>);</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a7fd97cbcf03d5c504401695619adfcff">CY_RRAM_VMODE_UNDEFINED</a> == <a class="code" href="group__group__rram__functions.html#ga2618b5aea210c4b19977c29bd799e7bd">Cy_RRAM_GetVoltageMode</a>(base))</div><div class="line">    {</div><div class="line">        <span class="comment">// Updated to undefined mode</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set mode to MF */</span></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2cbc23cc2062a2059b790c128ddc8409">Cy_RRAM_SetVoltageMode</a>(base, <a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a13d8ef9a8080eb12a60f524ddd6bccf1">CY_RRAM_VMODE_HP</a>);</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__enums.html#ggab670347c8e2e397a1b9fd82b6f31c002a13d8ef9a8080eb12a60f524ddd6bccf1">CY_RRAM_VMODE_HP</a> == <a class="code" href="group__group__rram__functions.html#ga2618b5aea210c4b19977c29bd799e7bd">Cy_RRAM_GetVoltageMode</a>(base))</div><div class="line">    {</div><div class="line">        <span class="comment">//Updated to MF mode</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">//Failed to update to MF mode</span></div><div class="line">    }</div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2cbc23cc2062a2059b790c128ddc8409">Cy_RRAM_SetVoltageMode</a>(base, mode);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga9e1a11952ba013fd1f5fa0f1cbcd6cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">&#9670;&nbsp;</a></span>Cy_RRAM_SetProtLockableRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> Cy_RRAM_SetProtLockableRegion </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of lockable region in PROTECTED_NVM region. </p>
<p>If size is larger than PROTECTERD_NVM, the entire PROTECTED_NVM is lockable. The lockable region can be configured only if the protected nvm lock state is unlocked. The configured region is protected only when the protected nvm lock state is locked</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">regionSize</td><td>Size of lockable region in KB. The valid range is 1-256.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status. Refer <a class="el" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    <span class="comment">/* Region size. */</span></div><div class="line">    uint32_t regionSize = 0x64;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822ac397308e77785222d0bf4bbf094d8f95">CY_RRAM_BAD_PARAM</a>;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint32_t addr = CY_RRAM_PROTECTED_PROTECTED_S_START_ADDRESS;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Update 100KB of PROTECTED_NVM region as lockable. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga54b93da74d4779f1207a722271c0e64f">Cy_RRAM_GetProtLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#gga2cd8e600602141f32af6d4bb707175fda000923fbd68f99387602d0d8ad13c787">CY_RRAM_PROTECTED_UNLOCK</a>)</div><div class="line">    {</div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">Cy_RRAM_SetProtLockableRegion</a>(base, regionSize);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>((regionSize -1U) == <a class="code" href="group__group__rram__functions.html#ga78b51e121f0f53673a3bccf174fe4eb0">Cy_RRAM_GetProtLockableRegion</a>(base) &amp;&amp; status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration success.</span></div><div class="line">        <a class="code" href="group__group__rram__functions.html#ga171fd1c80e4656c1593d47f75c9423d8">Cy_RRAM_SetProtLock</a>(base); <span class="comment">// Set the lock</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration fail.</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//Perform write operation on the protected region.</span></div><div class="line"></div><div class="line">    status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a>(base) == <a class="code" href="group__group__rram__enums.html#gga855ac505e4b109c962b3088b9bfbe87ea3492f14591e6da952380b2ab4ee8c3c1">CY_RRAM_PROTECTED_PRGM_ERROR</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Protected program error occurred. Failed to perform write operation on protected region</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Test case fail.</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for only CM0 secure enclave.</dd></dl>
<p>If size is larger than PROTECTERD_NVM, the entire PROTECTED_NVM is lockable. The lockable region can be configured only if the protected nvm lock state is unlocked. The configured region is protected only when the protected nvm lock state is locked </p>

</div>
</div>
<a id="ga78b51e121f0f53673a3bccf174fe4eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78b51e121f0f53673a3bccf174fe4eb0">&#9670;&nbsp;</a></span>Cy_RRAM_GetProtLockableRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_RRAM_GetProtLockableRegion </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of configured lockable region in PROTECTED_NVM region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of lockable region in KB.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    <span class="comment">/* Region size. */</span></div><div class="line">    uint32_t regionSize = 0x64;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822ac397308e77785222d0bf4bbf094d8f95">CY_RRAM_BAD_PARAM</a>;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint32_t addr = CY_RRAM_PROTECTED_PROTECTED_S_START_ADDRESS;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Update 100KB of PROTECTED_NVM region as lockable. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga54b93da74d4779f1207a722271c0e64f">Cy_RRAM_GetProtLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#gga2cd8e600602141f32af6d4bb707175fda000923fbd68f99387602d0d8ad13c787">CY_RRAM_PROTECTED_UNLOCK</a>)</div><div class="line">    {</div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">Cy_RRAM_SetProtLockableRegion</a>(base, regionSize);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>((regionSize -1U) == <a class="code" href="group__group__rram__functions.html#ga78b51e121f0f53673a3bccf174fe4eb0">Cy_RRAM_GetProtLockableRegion</a>(base) &amp;&amp; status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration success.</span></div><div class="line">        <a class="code" href="group__group__rram__functions.html#ga171fd1c80e4656c1593d47f75c9423d8">Cy_RRAM_SetProtLock</a>(base); <span class="comment">// Set the lock</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration fail.</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//Perform write operation on the protected region.</span></div><div class="line"></div><div class="line">    status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a>(base) == <a class="code" href="group__group__rram__enums.html#gga855ac505e4b109c962b3088b9bfbe87ea3492f14591e6da952380b2ab4ee8c3c1">CY_RRAM_PROTECTED_PRGM_ERROR</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Protected program error occurred. Failed to perform write operation on protected region</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Test case fail.</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for only CM0 secure enclave. </dd></dl>

</div>
</div>
<a id="ga171fd1c80e4656c1593d47f75c9423d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga171fd1c80e4656c1593d47f75c9423d8">&#9670;&nbsp;</a></span>Cy_RRAM_SetProtLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_SetProtLock </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the lock for the configured PROTECTED_NVM region <a class="el" href="group__group__rram__functions.html#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">Cy_RRAM_SetProtLockableRegion()</a>. </p>
<p>Updating the configured region and lockable programming are NOT allowed. The topmost 1KB of lockable region which is always writable regardless of lock status. Once locked, the lock state cannot be changed till next reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    <span class="comment">/* Region size. */</span></div><div class="line">    uint32_t regionSize = 0x64;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822ac397308e77785222d0bf4bbf094d8f95">CY_RRAM_BAD_PARAM</a>;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint32_t addr = CY_RRAM_PROTECTED_PROTECTED_S_START_ADDRESS;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Update 100KB of PROTECTED_NVM region as lockable. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga54b93da74d4779f1207a722271c0e64f">Cy_RRAM_GetProtLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#gga2cd8e600602141f32af6d4bb707175fda000923fbd68f99387602d0d8ad13c787">CY_RRAM_PROTECTED_UNLOCK</a>)</div><div class="line">    {</div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">Cy_RRAM_SetProtLockableRegion</a>(base, regionSize);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>((regionSize -1U) == <a class="code" href="group__group__rram__functions.html#ga78b51e121f0f53673a3bccf174fe4eb0">Cy_RRAM_GetProtLockableRegion</a>(base) &amp;&amp; status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration success.</span></div><div class="line">        <a class="code" href="group__group__rram__functions.html#ga171fd1c80e4656c1593d47f75c9423d8">Cy_RRAM_SetProtLock</a>(base); <span class="comment">// Set the lock</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration fail.</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//Perform write operation on the protected region.</span></div><div class="line"></div><div class="line">    status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a>(base) == <a class="code" href="group__group__rram__enums.html#gga855ac505e4b109c962b3088b9bfbe87ea3492f14591e6da952380b2ab4ee8c3c1">CY_RRAM_PROTECTED_PRGM_ERROR</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Protected program error occurred. Failed to perform write operation on protected region</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Test case fail.</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for only CM0 secure enclave. </dd></dl>

</div>
</div>
<a id="ga54b93da74d4779f1207a722271c0e64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54b93da74d4779f1207a722271c0e64f">&#9670;&nbsp;</a></span>Cy_RRAM_GetProtLockState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga2cd8e600602141f32af6d4bb707175fd">cy_en_rram_protected_lock_t</a> Cy_RRAM_GetProtLockState </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lock state of the PROTECTED_NVM Lockable region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State. <a class="el" href="group__group__rram__enums.html#ga2cd8e600602141f32af6d4bb707175fd">cy_en_rram_protected_lock_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    <span class="comment">/* Region size. */</span></div><div class="line">    uint32_t regionSize = 0x64;</div><div class="line">    <a class="code" href="group__group__rram__enums.html#gafd342752b2e13a0f640c987c826c9822">cy_en_rram_status_t</a> status = <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822ac397308e77785222d0bf4bbf094d8f95">CY_RRAM_BAD_PARAM</a>;</div><div class="line">    uint32_t numBytes = 0x10;</div><div class="line">    uint32_t addr = CY_RRAM_PROTECTED_PROTECTED_S_START_ADDRESS;</div><div class="line">    uint8_t writeData[numBytes];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i=0; i&lt;numBytes; i++)</div><div class="line">    {</div><div class="line">        writeData[i] = 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Update 100KB of PROTECTED_NVM region as lockable. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#ga54b93da74d4779f1207a722271c0e64f">Cy_RRAM_GetProtLockState</a>(base) == <a class="code" href="group__group__rram__enums.html#gga2cd8e600602141f32af6d4bb707175fda000923fbd68f99387602d0d8ad13c787">CY_RRAM_PROTECTED_UNLOCK</a>)</div><div class="line">    {</div><div class="line">        status = <a class="code" href="group__group__rram__functions.html#ga9e1a11952ba013fd1f5fa0f1cbcd6cd3">Cy_RRAM_SetProtLockableRegion</a>(base, regionSize);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>((regionSize -1U) == <a class="code" href="group__group__rram__functions.html#ga78b51e121f0f53673a3bccf174fe4eb0">Cy_RRAM_GetProtLockableRegion</a>(base) &amp;&amp; status == <a class="code" href="group__group__rram__enums.html#ggafd342752b2e13a0f640c987c826c9822a948d357faaa549be067055c8eaf0c492">CY_RRAM_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration success.</span></div><div class="line">        <a class="code" href="group__group__rram__functions.html#ga171fd1c80e4656c1593d47f75c9423d8">Cy_RRAM_SetProtLock</a>(base); <span class="comment">// Set the lock</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Configuration fail.</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//Perform write operation on the protected region.</span></div><div class="line"></div><div class="line">    status = <a class="code" href="group__group__rram__functions.html#ga7e80ece896f80a3eb042d1d7b7b2bb1d">Cy_RRAM_NvmWriteByteArray</a>(base, addr, writeData, numBytes);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__rram__functions.html#gacdaa2e260da5c0623f5ef257103d439f">Cy_RRAM_GetAHBError</a>(base) == <a class="code" href="group__group__rram__enums.html#gga855ac505e4b109c962b3088b9bfbe87ea3492f14591e6da952380b2ab4ee8c3c1">CY_RRAM_PROTECTED_PRGM_ERROR</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//Protected program error occurred. Failed to perform write operation on protected region</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Test case fail.</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for only CM0 secure enclave. </dd></dl>

</div>
</div>
<a id="ga2d4ffac792856fb5ed9f2638af117b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d4ffac792856fb5ed9f2638af117b95">&#9670;&nbsp;</a></span>Cy_RRAM_SetUDSLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_SetUDSLock </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the lock to avoid access to UDS key. </p>
<p>Once locked, the lock state cannot be changed till next reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    <span class="comment">/* Scenario: Set the lock bit. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure UDS to generate AHB error when UDS is locked and read access is done to UDS */</span></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2bd175a5ed35ca43b6ac2c8a6027a3ab">Cy_RRAM_SetUDSConfig</a>(base, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2d4ffac792856fb5ed9f2638af117b95">Cy_RRAM_SetUDSLock</a>(base);</div><div class="line"></div><div class="line">    <span class="comment">/* Get status of UDS lock */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga8ca3563334bdd5f808c929837f4e107e">cy_en_rram_uds_lock_t</a> udsLockState = <a class="code" href="group__group__rram__functions.html#ga8da4812551d55a196b6f54152728dc42">Cy_RRAM_GetUDSLockState</a>(base);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for only CM0 secure enclave. </dd></dl>

</div>
</div>
<a id="ga8da4812551d55a196b6f54152728dc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da4812551d55a196b6f54152728dc42">&#9670;&nbsp;</a></span>Cy_RRAM_GetUDSLockState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__rram__enums.html#ga8ca3563334bdd5f808c929837f4e107e">cy_en_rram_uds_lock_t</a> Cy_RRAM_GetUDSLockState </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of UDS lock. </p>
<p>If it is locked then there will be no access to UDS key. Until the lock is unlocked. The lock state cannot be changed till next reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lockState State of the lock. Refer <a class="el" href="group__group__rram__enums.html#ga8ca3563334bdd5f808c929837f4e107e">cy_en_rram_uds_lock_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    <span class="comment">/* Scenario: Set the lock bit. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure UDS to generate AHB error when UDS is locked and read access is done to UDS */</span></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2bd175a5ed35ca43b6ac2c8a6027a3ab">Cy_RRAM_SetUDSConfig</a>(base, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2d4ffac792856fb5ed9f2638af117b95">Cy_RRAM_SetUDSLock</a>(base);</div><div class="line"></div><div class="line">    <span class="comment">/* Get status of UDS lock */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga8ca3563334bdd5f808c929837f4e107e">cy_en_rram_uds_lock_t</a> udsLockState = <a class="code" href="group__group__rram__functions.html#ga8da4812551d55a196b6f54152728dc42">Cy_RRAM_GetUDSLockState</a>(base);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for only CM0 secure enclave. </dd></dl>

</div>
</div>
<a id="ga2bd175a5ed35ca43b6ac2c8a6027a3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd175a5ed35ca43b6ac2c8a6027a3ab">&#9670;&nbsp;</a></span>Cy_RRAM_SetUDSConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_SetUDSConfig </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure UDS to trigger a AHB error or read as zero without error when there is a read access to UDS. </p>
<p>It is effective only when UDS is locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the RRAMC instance.</td></tr>
    <tr><td class="paramname">config</td><td>Set to true to trigger AHB error when there is a read access to UDS. Set to false to return read as zero for the read access without any AHB error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    RRAMC_Type * base = RRAMC0;</div><div class="line">    <span class="comment">/* Scenario: Set the lock bit. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure UDS to generate AHB error when UDS is locked and read access is done to UDS */</span></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2bd175a5ed35ca43b6ac2c8a6027a3ab">Cy_RRAM_SetUDSConfig</a>(base, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__rram__functions.html#ga2d4ffac792856fb5ed9f2638af117b95">Cy_RRAM_SetUDSLock</a>(base);</div><div class="line"></div><div class="line">    <span class="comment">/* Get status of UDS lock */</span></div><div class="line">    <a class="code" href="group__group__rram__enums.html#ga8ca3563334bdd5f808c929837f4e107e">cy_en_rram_uds_lock_t</a> udsLockState = <a class="code" href="group__group__rram__functions.html#ga8da4812551d55a196b6f54152728dc42">Cy_RRAM_GetUDSLockState</a>(base);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for only CM0 secure enclave. </dd></dl>

</div>
</div>
<a id="ga5b3af8c8d7c2b521eb53f5ef47e3f88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b3af8c8d7c2b521eb53f5ef47e3f88b">&#9670;&nbsp;</a></span>Cy_RRAM_ForceRelPCLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_RRAM_ForceRelPCLock </td>
          <td>(</td>
          <td class="paramtype">RRAMC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release PC lock forcefully. </p>
<p>In order to avoid deadlock situation during indirect write operation, CM0 has the capability to release or break the acquired lock. Should be called only when a pc lock acquired by CM33/CM55 during indirect write operation needs be released forcefully. This API can be called before the start of write operation from CM0. This API is only available for CM0 secure enclave. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
