<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__nn__kernel__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">functions<div class="ingroups"><a class="el" href="group__group__nn__kernel.html">NNLITE HW Accelerator KERNEL LIB</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5993891adf086eba6e1e0bd4f2b70f95"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga5993891adf086eba6e1e0bd4f2b70f95">Cy_NNLite_GetAvgPoolKernelWeightSize</a> (void)</td></tr>
<tr class="memdesc:ga5993891adf086eba6e1e0bd4f2b70f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function which returns a "virtual-weights" array's size for average pooling cases.  <a href="#ga5993891adf086eba6e1e0bd4f2b70f95">More...</a><br /></td></tr>
<tr class="separator:ga5993891adf086eba6e1e0bd4f2b70f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb86ad46f3260b161ca6e7a06e5d50a3"><td class="memItemLeft" align="right" valign="top">int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#gacb86ad46f3260b161ca6e7a06e5d50a3">Cy_NNLite_GetAvgPoolKernelWeightPtr</a> (void)</td></tr>
<tr class="memdesc:gacb86ad46f3260b161ca6e7a06e5d50a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return AvgPool Kernel weight pointer All-ones const weights array used by AvgPool Size is returned by Cy_NNLite_GetAvgPoolKernelWeightSize.  <a href="#gacb86ad46f3260b161ca6e7a06e5d50a3">More...</a><br /></td></tr>
<tr class="separator:gacb86ad46f3260b161ca6e7a06e5d50a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db995ae1e1cb790b919a7b1c18ef197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga7db995ae1e1cb790b919a7b1c18ef197">Cy_NNLite_SetAvgPoolKernelWeightArrayPtr</a> (int8_t *weightsArrayPtr, uint32_t weightsArraySize)</td></tr>
<tr class="memdesc:ga7db995ae1e1cb790b919a7b1c18ef197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function set "virtual-weights" array's pointer and size for average pooling cases when valid pointer and size is passed, in case of NULL pointer or 0 size array's pointer will be reset to default value pointer should not be freed untill AvgPool weight pointer is reset to default by calling same API with NULL pointer value or 0 size in argument.  <a href="#ga7db995ae1e1cb790b919a7b1c18ef197">More...</a><br /></td></tr>
<tr class="separator:ga7db995ae1e1cb790b919a7b1c18ef197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9a7f1fde2d9ac0a2cf7105964b0322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga1a9a7f1fde2d9ac0a2cf7105964b0322">Cy_NNLite_Convolution</a> (const int8_t *inputData, int8_t *outData, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const int8_t *filterData, const int32_t *biasData, const void *sparsityBaseAddr, <a class="el" href="structcy__nn__conv__params__t.html">cy_nn_conv_params_t</a> *convParam, <a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a> actType, <a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *intrplParam)</td></tr>
<tr class="memdesc:ga1a9a7f1fde2d9ac0a2cf7105964b0322"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D Convolution CPU mode kernel API, API will configure nnlite and then start nnlite operation.Callback function from kernel config structure will be called after completion of layer.  <a href="#ga1a9a7f1fde2d9ac0a2cf7105964b0322">More...</a><br /></td></tr>
<tr class="separator:ga1a9a7f1fde2d9ac0a2cf7105964b0322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb143a20fc12969e634e9e2bc785dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga6fb143a20fc12969e634e9e2bc785dc1">Cy_NNLite_FullyConnected</a> (const int8_t *inputData, int8_t *outData, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const int8_t *filterData, const int32_t *biasData, const void *sparsityBaseAddr, <a class="el" href="structcy__nn__fc__params__t.html">cy_nn_fc_params_t</a> *fcParam, <a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a> actType, <a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *intrplParam)</td></tr>
<tr class="memdesc:ga6fb143a20fc12969e634e9e2bc785dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully connected CPU mode kernel API, API will configure nnlite and then start nnlite operation.Callback function from kernel config structure will be called after completion of layer.  <a href="#ga6fb143a20fc12969e634e9e2bc785dc1">More...</a><br /></td></tr>
<tr class="separator:ga6fb143a20fc12969e634e9e2bc785dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c398c5b25ee2bfe6823aa10d8ad2f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga4c398c5b25ee2bfe6823aa10d8ad2f91">Cy_NNLite_Avgpool</a> (const int8_t *inputData, int8_t *outData, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, <a class="el" href="structcy__nn__avgpool__params__t.html">cy_nn_avgpool_params_t</a> *avgpoolParam)</td></tr>
<tr class="memdesc:ga4c398c5b25ee2bfe6823aa10d8ad2f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average pool CPU mode kernel API, API will configure nnlite.  <a href="#ga4c398c5b25ee2bfe6823aa10d8ad2f91">More...</a><br /></td></tr>
<tr class="separator:ga4c398c5b25ee2bfe6823aa10d8ad2f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11ce4a6adf9e74a6fc36b3ed9f3ad6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#gab11ce4a6adf9e74a6fc36b3ed9f3ad6d">Cy_NNLite_ConvolutionDMA</a> (const int8_t *inputData, int8_t *outData, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const int8_t *filterData, const int32_t *biasData, const void *sparsityBaseAddr, <a class="el" href="structcy__nn__conv__params__t.html">cy_nn_conv_params_t</a> *convParam, <a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a> actType, <a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *intrplParam)</td></tr>
<tr class="memdesc:gab11ce4a6adf9e74a6fc36b3ed9f3ad6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D Convolution kernel DMA API, API will fill DMA descriptor pointing nnlite MEMIO configuration structure.  <a href="#gab11ce4a6adf9e74a6fc36b3ed9f3ad6d">More...</a><br /></td></tr>
<tr class="separator:gab11ce4a6adf9e74a6fc36b3ed9f3ad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85036caebab3f1874ba9030a30af2255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga85036caebab3f1874ba9030a30af2255">Cy_NNLite_FullyConnectedDMA</a> (const int8_t *inputData, int8_t *outData, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const int8_t *filterData, const int32_t *biasData, const void *sparsityBaseAddr, <a class="el" href="structcy__nn__fc__params__t.html">cy_nn_fc_params_t</a> *fcParam, <a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a> actType, <a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *intrplParam)</td></tr>
<tr class="memdesc:ga85036caebab3f1874ba9030a30af2255"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA based fully connected(Dense) kernel API, API will fill DMA descriptor pointing NNLite MEMIO configuration structure.  <a href="#ga85036caebab3f1874ba9030a30af2255">More...</a><br /></td></tr>
<tr class="separator:ga85036caebab3f1874ba9030a30af2255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b62f7cf26d3801cfb4146745eb1df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga03b62f7cf26d3801cfb4146745eb1df5">Cy_NNLite_AvgpoolDMA</a> (const int8_t *inputData, int8_t *outData, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, <a class="el" href="structcy__nn__avgpool__params__t.html">cy_nn_avgpool_params_t</a> *avgpoolParam)</td></tr>
<tr class="memdesc:ga03b62f7cf26d3801cfb4146745eb1df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average pool kernel API DMA mode, API will fill DMA descriptor pointing NNLite MEMIO configuration structure.Implemented in nnlite using convolution.  <a href="#ga03b62f7cf26d3801cfb4146745eb1df5">More...</a><br /></td></tr>
<tr class="separator:ga03b62f7cf26d3801cfb4146745eb1df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f1ab40879e8ec6bf78fac24502e08cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga0f1ab40879e8ec6bf78fac24502e08cb">Cy_NNLite_TriggerDMAQueue</a> (void)</td></tr>
<tr class="memdesc:ga0f1ab40879e8ec6bf78fac24502e08cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cy_NNLite_TriggerDMAQueue will trigger DMA transfer of Queued layer starting from first queued layer, callback function will be called after completion of all the Queued layer if valid callback function is passed in kenel context, API will work in blocking mode if callback function is NULL.  <a href="#ga0f1ab40879e8ec6bf78fac24502e08cb">More...</a><br /></td></tr>
<tr class="separator:ga0f1ab40879e8ec6bf78fac24502e08cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7d7281eed1a4a04dc5e7198a286376"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga2e7d7281eed1a4a04dc5e7198a286376">Cy_NNLite_GetQueuedLayerCount</a> (void)</td></tr>
<tr class="memdesc:ga2e7d7281eed1a4a04dc5e7198a286376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cy_NNLite_GetQueuedLayerCount will return count of queued layer for DMA.  <a href="#ga2e7d7281eed1a4a04dc5e7198a286376">More...</a><br /></td></tr>
<tr class="separator:ga2e7d7281eed1a4a04dc5e7198a286376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963081d3ee476c62770dd70d091127e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga963081d3ee476c62770dd70d091127e2">Cy_NNLite_AvgpoolScratchBufSize</a> (const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outDims)</td></tr>
<tr class="memdesc:ga963081d3ee476c62770dd70d091127e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">API will return return size of scratch buffer in bytes for Average pool kernel in CPU mode, buffer size will be equal to filter dimensions.  <a href="#ga963081d3ee476c62770dd70d091127e2">More...</a><br /></td></tr>
<tr class="separator:ga963081d3ee476c62770dd70d091127e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08de333de0136044f38391dd9d34454a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga08de333de0136044f38391dd9d34454a">Cy_NNLite_AvgpoolDMAScratchBufSize</a> (const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *inDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outDims)</td></tr>
<tr class="memdesc:ga08de333de0136044f38391dd9d34454a"><td class="mdescLeft">&#160;</td><td class="mdescRight">API will return return size of scratch buffer in bytes for Average pool kernel in DMA mode, buffer size will be equal to filter dimensions plus cy_nnlite_memio_dma_t and dma descriptors, cy_nnlite_memio_dma_t will be used as source pointer having nnlite MEMIO configuration.  <a href="#ga08de333de0136044f38391dd9d34454a">More...</a><br /></td></tr>
<tr class="separator:ga08de333de0136044f38391dd9d34454a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e2cb0dee5a5b4df4205f21d51d24051"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga7e2cb0dee5a5b4df4205f21d51d24051">Cy_NNLite_ConvolutionScratchBufSize</a> (const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, float *outScalingFactor)</td></tr>
<tr class="memdesc:ga7e2cb0dee5a5b4df4205f21d51d24051"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConvolutionScratchBufSize API will return scratch buffer size for convolution kernel CPU mode, buffer will be used for transpose function which will required scratch buffer equal to outbuffer plus DMA descriptor, count of descriptors depends on size of output buffer if all scaling factor pointed by outScalingFactor are equal, transpose functionality will not be required and size return will be 0 bytes.  <a href="#ga7e2cb0dee5a5b4df4205f21d51d24051">More...</a><br /></td></tr>
<tr class="separator:ga7e2cb0dee5a5b4df4205f21d51d24051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899d3a2e900607a576e1f132320a9070"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga899d3a2e900607a576e1f132320a9070">Cy_NNLite_ConvolutionDMAScratchBufSize</a> (const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *filterDims, const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *outputDims, float *outScalingFactor)</td></tr>
<tr class="memdesc:ga899d3a2e900607a576e1f132320a9070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cy_NNLite_ConvolutionDMAScratchBufSize API will return scratch buffer size for convolution kernel DMA mode, buffer will be used for cy_nnlite_memio_dma_t * number of filters plus transpose function which will required scratch buffer equal to outbuffer plus DMA descriptors, count of descriptors depends on size of output buffer if all scaling factor pointed by outScalingFactor are equal, transpose functionality will not be required, buffer size will be for only for DMA operation.  <a href="#ga899d3a2e900607a576e1f132320a9070">More...</a><br /></td></tr>
<tr class="separator:ga899d3a2e900607a576e1f132320a9070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9bfe66a243a16205d7cb7e7e0f45f59"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#gaf9bfe66a243a16205d7cb7e7e0f45f59">Cy_NNLite_FullyConnectedDMAScratchBufSize</a> (void)</td></tr>
<tr class="memdesc:gaf9bfe66a243a16205d7cb7e7e0f45f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">API will return scratch buffer size for fully connected DMA mode kernel, buffer will be used for DMA descriptors and for MEMIO configuration structure of type cy_nnlite_memio_dma_t for DMA.  <a href="#gaf9bfe66a243a16205d7cb7e7e0f45f59">More...</a><br /></td></tr>
<tr class="separator:gaf9bfe66a243a16205d7cb7e7e0f45f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30aabc8d3c9ac00f08c73b3ad51c2f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga30aabc8d3c9ac00f08c73b3ad51c2f92">Cy_NNLite_GetCurrDMAQueue</a> (<a class="el" href="structcy__nnlite__dma__queue__config__t.html">cy_nnlite_dma_queue_config_t</a> *dmaQueue)</td></tr>
<tr class="memdesc:ga30aabc8d3c9ac00f08c73b3ad51c2f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cy_NNLite_GetCurrDMAQueue API will copy current dma queue in to dmaQueue pointer, valid dmaQueue pointer should be passed.  <a href="#ga30aabc8d3c9ac00f08c73b3ad51c2f92">More...</a><br /></td></tr>
<tr class="separator:ga30aabc8d3c9ac00f08c73b3ad51c2f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecab45a2c729ad12523ad57066f413f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#gaecab45a2c729ad12523ad57066f413f3">Cy_NNLite_RunDMAQueue</a> (<a class="el" href="structcy__nnlite__dma__queue__config__t.html">cy_nnlite_dma_queue_config_t</a> *dmaQueue)</td></tr>
<tr class="memdesc:gaecab45a2c729ad12523ad57066f413f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cy_NNLite_RunDMAQueue API will Trigger DMA dmaQueue queue valid dmaQueue pointer should be passed, DMA queue should return from Cy_NNLite_GetCurrDMAQueue queue will be in runnable state if Cy_NNLite_GetCurrDMAQueue called after queue created in Kernel DMA API such as Cy_NNLite_AvgpoolDMA and get executed by calling Cy_NNLite_TriggerDMAQueue.  <a href="#gaecab45a2c729ad12523ad57066f413f3">More...</a><br /></td></tr>
<tr class="separator:gaecab45a2c729ad12523ad57066f413f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80cc663bc1668fe1a9167335e8985173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#ga80cc663bc1668fe1a9167335e8985173">Cy_NNLite_KernelInit</a> (<a class="el" href="structcy__kernel__config__t.html">cy_kernel_config_t</a> *kernelConfig)</td></tr>
<tr class="memdesc:ga80cc663bc1668fe1a9167335e8985173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel Init API, initializes PDL driver and setup IRQ handler and setup function pointers from kernelConfig argument.  <a href="#ga80cc663bc1668fe1a9167335e8985173">More...</a><br /></td></tr>
<tr class="separator:ga80cc663bc1668fe1a9167335e8985173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf938f97f72466428554fe4694cc25722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__nn__kernel__functions.html#gaf938f97f72466428554fe4694cc25722">Cy_NNLite_KernelDeInit</a> (void)</td></tr>
<tr class="memdesc:gaf938f97f72466428554fe4694cc25722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel Deinit API, de-initialize PDL driver and synchronization primitives.  <a href="#gaf938f97f72466428554fe4694cc25722">More...</a><br /></td></tr>
<tr class="separator:gaf938f97f72466428554fe4694cc25722"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5993891adf086eba6e1e0bd4f2b70f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5993891adf086eba6e1e0bd4f2b70f95">&#9670;&nbsp;</a></span>Cy_NNLite_GetAvgPoolKernelWeightSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_NNLite_GetAvgPoolKernelWeightSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function which returns a "virtual-weights" array's size for average pooling cases. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">size</td><td>of AvgPool Kernel weights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb86ad46f3260b161ca6e7a06e5d50a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb86ad46f3260b161ca6e7a06e5d50a3">&#9670;&nbsp;</a></span>Cy_NNLite_GetAvgPoolKernelWeightPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t* Cy_NNLite_GetAvgPoolKernelWeightPtr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return AvgPool Kernel weight pointer All-ones const weights array used by AvgPool Size is returned by Cy_NNLite_GetAvgPoolKernelWeightSize. </p>
<p>These are best held in non-volatile "code" memory as the NNLite's bus connectivity is optimized for this. Held in SRAM banks will result in heavy contention between the weight and activation streaming engines.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Avg</td><td>Pool weight array pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7db995ae1e1cb790b919a7b1c18ef197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db995ae1e1cb790b919a7b1c18ef197">&#9670;&nbsp;</a></span>Cy_NNLite_SetAvgPoolKernelWeightArrayPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_SetAvgPoolKernelWeightArrayPtr </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>weightsArrayPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>weightsArraySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function set "virtual-weights" array's pointer and size for average pooling cases when valid pointer and size is passed, in case of NULL pointer or 0 size array's pointer will be reset to default value pointer should not be freed untill AvgPool weight pointer is reset to default by calling same API with NULL pointer value or 0 size in argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">weightsArrayPtr</td><td>AvgPool Kernel weight array pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weightsArraySize</td><td>AvgPool Kernel weight array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a9a7f1fde2d9ac0a2cf7105964b0322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a9a7f1fde2d9ac0a2cf7105964b0322">&#9670;&nbsp;</a></span>Cy_NNLite_Convolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_Convolution </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>filterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>biasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sparsityBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__conv__params__t.html">cy_nn_conv_params_t</a> *&#160;</td>
          <td class="paramname"><em>convParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a>&#160;</td>
          <td class="paramname"><em>actType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *&#160;</td>
          <td class="paramname"><em>intrplParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D Convolution CPU mode kernel API, API will configure nnlite and then start nnlite operation.Callback function from kernel config structure will be called after completion of layer. </p>
<p>Kernel config structure should point to valid callback function. intrplParam can be passed as NULL for default behavior of activation, to parametrize activation pass valid intrplParam. filterData points to weights if sparsityBaseAddr is NULL otherwise weights pointer will be derived from sparsityBaseAddr and filterData will not be used. Valid scratch buffer should be passed in convParam, scratch buffer will be used for transpose operation (transpose scratch buffer and transpose DMA descriptors)for per axis convolution implementation, size of scratch buffer should be derived by calling function Cy_NNLite_ConvolutionScratchBufSize. Scratch buffer should be 4 byte aligned, and can be freed after receving completion callback of API in case non blocking mode. For Multiscaling outData pointer should be 4 byte aligned for DMA transpose</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>activation buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outData</td><td>output buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputDims</td><td>activation dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>filter pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biasData</td><td>bias pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsityBaseAddr</td><td>sparesity map base pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convParam</td><td>convolution parameter structure pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actType</td><td>output activation type</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intrplParam</td><td>interpolation param for output activation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fb143a20fc12969e634e9e2bc785dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb143a20fc12969e634e9e2bc785dc1">&#9670;&nbsp;</a></span>Cy_NNLite_FullyConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_FullyConnected </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>filterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>biasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sparsityBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__fc__params__t.html">cy_nn_fc_params_t</a> *&#160;</td>
          <td class="paramname"><em>fcParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a>&#160;</td>
          <td class="paramname"><em>actType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *&#160;</td>
          <td class="paramname"><em>intrplParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully connected CPU mode kernel API, API will configure nnlite and then start nnlite operation.Callback function from kernel config structure will be called after completion of layer. </p>
<p>Kernel config structure should point to valid callback function. intrplParam can be passed as NULL for default behavior of activation, to parametrize activation pass valid intrplParam. filterData points to weights If sparsityBaseAddr is NULL, otherwise weights pointer will be derived from sparsityBaseAddr and filterData will not be used. No scratch buffer is required in CPU mode fully connected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>activation buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outData</td><td>output buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputDims</td><td>activation dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>filter pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biasData</td><td>bias pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsityBaseAddr</td><td>sparesity map base pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcParam</td><td>fully Connected parameter structure pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actType</td><td>output activation type</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intrplParam</td><td>interpolation param for output activation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c398c5b25ee2bfe6823aa10d8ad2f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c398c5b25ee2bfe6823aa10d8ad2f91">&#9670;&nbsp;</a></span>Cy_NNLite_Avgpool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_Avgpool </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__avgpool__params__t.html">cy_nn_avgpool_params_t</a> *&#160;</td>
          <td class="paramname"><em>avgpoolParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average pool CPU mode kernel API, API will configure nnlite. </p>
<p>and then start nnlite operation.Callback function from kernel config structure will be called after completion of layer.Kernel config structure should point to valid callback function.Implemented using convolution in nnlite. Valid scratch buffer should be allocated and passed in avgpoolParam and scratch buffer should be 4 byte aligned. Size of scratch buffer should be calculated using API Cy_NNLite_AvgpoolDMAScratchBufSize Scratch buffer can be freed after receving completion callback of API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>activation buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outData</td><td>output buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputDims</td><td>activation dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avgpoolParam</td><td>average pool parameter structure pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab11ce4a6adf9e74a6fc36b3ed9f3ad6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab11ce4a6adf9e74a6fc36b3ed9f3ad6d">&#9670;&nbsp;</a></span>Cy_NNLite_ConvolutionDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_ConvolutionDMA </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>filterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>biasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sparsityBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__conv__params__t.html">cy_nn_conv_params_t</a> *&#160;</td>
          <td class="paramname"><em>convParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a>&#160;</td>
          <td class="paramname"><em>actType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *&#160;</td>
          <td class="paramname"><em>intrplParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D Convolution kernel DMA API, API will fill DMA descriptor pointing nnlite MEMIO configuration structure. </p>
<p>intrplParam can be passed as NULL for default behavior of activation, to parametrize activation pass valid intrplParam. filterData points to weights If sparsityBaseAddr is NULL otherwise weights pointer will be derived from sparsityBaseAddr and filterData will not be used. Valid scratch buffer should be passed in convParam, scratch buffer will be used for nnlite MEMIO configuration structure (per axis 1), and for transpose operation for per axis (transpose scratch buffer and transpose DMA descriptors) convolution implementation, size of scratch buffer should be derived by calling function Cy_NNLite_ConvolutionScratchBufSize. Scratch buffer should be 4 byte aligned and can be freed after receving completion callback in case of Non blocking mode. N convolutions Descriptors and Transpose Descriptors will be Queue in DMA together. CY_NNLITE_OP_QUEUED will be the return value on success After queuing kernel, DMA needs to be triggered by calling API Cy_TriggerNNLiteDMAQueue.Callback function from kernel config structure will be called after completion of all queued layers kernel config structure should point to valid callback function. For Multiscaling outData pointer should be 4 byte aligned for DMA transpose </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>activation buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outData</td><td>output buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputDims</td><td>activation dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>filter pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biasData</td><td>bias pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsityBaseAddr</td><td>sparesity map base pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convParam</td><td>convolution parameter structure pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actType</td><td>output activation type</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intrplParam</td><td>interpolation param for output activation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85036caebab3f1874ba9030a30af2255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85036caebab3f1874ba9030a30af2255">&#9670;&nbsp;</a></span>Cy_NNLite_FullyConnectedDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_FullyConnectedDMA </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>filterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>biasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sparsityBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__fc__params__t.html">cy_nn_fc_params_t</a> *&#160;</td>
          <td class="paramname"><em>fcParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__nnlite__enums.html#ga384cb7d2feea111076bbd75ae43e60f6">cy_en_nnlite_fused_activation_t</a>&#160;</td>
          <td class="paramname"><em>actType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__act__intrpl__param__t.html">cy_nn_act_intrpl_param_t</a> *&#160;</td>
          <td class="paramname"><em>intrplParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA based fully connected(Dense) kernel API, API will fill DMA descriptor pointing NNLite MEMIO configuration structure. </p>
<p>intrplParam can be passed as NULL for default behavior of activation, to parametrize activation pass valid intrplParam. filterData points to weights if sparsityBaseAddr is NULL otherwise weights pointer will be derived from sparsityBaseAddr and filterData will not be used. Valid scratch buffer should be passed in fcParam, scratch buffer will be used for DMA descriptors and for nnlite MEMIO configuration structure for DMA. Size of scratch buffer should be calculated using API Cy_NNLite_FullyConnectedDMAScratchBufSize API will setup DMA descriptor and will Queue DMA operation. CY_NNLITE_OP_QUEUED will be the return value on success After queuing kernel, DMA needs to be triggered by calling API Cy_TriggerNNLiteDMAQueue. Callback function from kernel config will be called after completion of all queued layers, kernel config structure should point to valid callback function.Scratch buffer can be freed after receving completion callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>activation buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outData</td><td>output buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputDims</td><td>activation dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>filter pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biasData</td><td>bias pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsityBaseAddr</td><td>sparesity map base pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcParam</td><td>fully Connected parameter structure pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actType</td><td>output activation type</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intrplParam</td><td>interpolation param for output activation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03b62f7cf26d3801cfb4146745eb1df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b62f7cf26d3801cfb4146745eb1df5">&#9670;&nbsp;</a></span>Cy_NNLite_AvgpoolDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_AvgpoolDMA </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__nn__avgpool__params__t.html">cy_nn_avgpool_params_t</a> *&#160;</td>
          <td class="paramname"><em>avgpoolParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average pool kernel API DMA mode, API will fill DMA descriptor pointing NNLite MEMIO configuration structure.Implemented in nnlite using convolution. </p>
<p>Valid scratch buffer should be allocated and passed in avgpoolParam. Scatch buffer should be 4 byte aligned and size of scratch buffer should be calculated using API Cy_NNLite_AvgPoolDMAScratchBufSize. Scratch buffer will be used for DMA descriptors and for MEMIO configuration structure and for creating weights for weights streamer for convolution operation. API will setup DMA descriptor and will Queue DMA operation. CY_NNLITE_OP_QUEUED will be the return value on success After queuing kernel, DMA needs to be triggered by calling API Cy_TriggerNNLiteDMAQueue. Callback function from kernel config will be called after completion of all queued layers,kernel config structure should point to valid callback function. Scratch buffer can be freed after receving completion callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>activation buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outData</td><td>output buffer pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputDims</td><td>activation dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension pointer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avgpoolParam</td><td>average pool parameter structure pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f1ab40879e8ec6bf78fac24502e08cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f1ab40879e8ec6bf78fac24502e08cb">&#9670;&nbsp;</a></span>Cy_NNLite_TriggerDMAQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_TriggerDMAQueue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cy_NNLite_TriggerDMAQueue will trigger DMA transfer of Queued layer starting from first queued layer, callback function will be called after completion of all the Queued layer if valid callback function is passed in kenel context, API will work in blocking mode if callback function is NULL. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e7d7281eed1a4a04dc5e7198a286376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7d7281eed1a4a04dc5e7198a286376">&#9670;&nbsp;</a></span>Cy_NNLite_GetQueuedLayerCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_NNLite_GetQueuedLayerCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cy_NNLite_GetQueuedLayerCount will return count of queued layer for DMA. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">dmaQDepth</td><td>number of layers in DMA Queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga963081d3ee476c62770dd70d091127e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga963081d3ee476c62770dd70d091127e2">&#9670;&nbsp;</a></span>Cy_NNLite_AvgpoolScratchBufSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_NNLite_AvgpoolScratchBufSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API will return return size of scratch buffer in bytes for Average pool kernel in CPU mode, buffer size will be equal to filter dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inDims</td><td>input dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outDims</td><td>output dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">buffer</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08de333de0136044f38391dd9d34454a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08de333de0136044f38391dd9d34454a">&#9670;&nbsp;</a></span>Cy_NNLite_AvgpoolDMAScratchBufSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_NNLite_AvgpoolDMAScratchBufSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>inDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API will return return size of scratch buffer in bytes for Average pool kernel in DMA mode, buffer size will be equal to filter dimensions plus cy_nnlite_memio_dma_t and dma descriptors, cy_nnlite_memio_dma_t will be used as source pointer having nnlite MEMIO configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inDims</td><td>input dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outDims</td><td>output dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">buffer</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e2cb0dee5a5b4df4205f21d51d24051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e2cb0dee5a5b4df4205f21d51d24051">&#9670;&nbsp;</a></span>Cy_NNLite_ConvolutionScratchBufSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_NNLite_ConvolutionScratchBufSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outScalingFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ConvolutionScratchBufSize API will return scratch buffer size for convolution kernel CPU mode, buffer will be used for transpose function which will required scratch buffer equal to outbuffer plus DMA descriptor, count of descriptors depends on size of output buffer if all scaling factor pointed by outScalingFactor are equal, transpose functionality will not be required and size return will be 0 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outScalingFactor</td><td>scaling factor array pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">buffer</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga899d3a2e900607a576e1f132320a9070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga899d3a2e900607a576e1f132320a9070">&#9670;&nbsp;</a></span>Cy_NNLite_ConvolutionDMAScratchBufSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_NNLite_ConvolutionDMAScratchBufSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>filterDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__nn__dims__t.html">cy_nn_dims_t</a> *&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outScalingFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cy_NNLite_ConvolutionDMAScratchBufSize API will return scratch buffer size for convolution kernel DMA mode, buffer will be used for cy_nnlite_memio_dma_t * number of filters plus transpose function which will required scratch buffer equal to outbuffer plus DMA descriptors, count of descriptors depends on size of output buffer if all scaling factor pointed by outScalingFactor are equal, transpose functionality will not be required, buffer size will be for only for DMA operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filterDims</td><td>filter dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputDims</td><td>output dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outScalingFactor</td><td>scaling factor array pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">buffer</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9bfe66a243a16205d7cb7e7e0f45f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9bfe66a243a16205d7cb7e7e0f45f59">&#9670;&nbsp;</a></span>Cy_NNLite_FullyConnectedDMAScratchBufSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_NNLite_FullyConnectedDMAScratchBufSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API will return scratch buffer size for fully connected DMA mode kernel, buffer will be used for DMA descriptors and for MEMIO configuration structure of type cy_nnlite_memio_dma_t for DMA. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">buffer</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30aabc8d3c9ac00f08c73b3ad51c2f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30aabc8d3c9ac00f08c73b3ad51c2f92">&#9670;&nbsp;</a></span>Cy_NNLite_GetCurrDMAQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_GetCurrDMAQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__nnlite__dma__queue__config__t.html">cy_nnlite_dma_queue_config_t</a> *&#160;</td>
          <td class="paramname"><em>dmaQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cy_NNLite_GetCurrDMAQueue API will copy current dma queue in to dmaQueue pointer, valid dmaQueue pointer should be passed. </p>
<p>To get the runnable queue Cy_NNLite_GetCurrDMAQueue should be called after the created in Kernel DMA API such as Cy_NNLite_AvgpoolDMA and get executed by calling Cy_NNLite_TriggerDMAQueue</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dmaQueue</td><td>dma queue pointer in which dma queue will be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecab45a2c729ad12523ad57066f413f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecab45a2c729ad12523ad57066f413f3">&#9670;&nbsp;</a></span>Cy_NNLite_RunDMAQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_RunDMAQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__nnlite__dma__queue__config__t.html">cy_nnlite_dma_queue_config_t</a> *&#160;</td>
          <td class="paramname"><em>dmaQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cy_NNLite_RunDMAQueue API will Trigger DMA dmaQueue queue valid dmaQueue pointer should be passed, DMA queue should return from Cy_NNLite_GetCurrDMAQueue queue will be in runnable state if Cy_NNLite_GetCurrDMAQueue called after queue created in Kernel DMA API such as Cy_NNLite_AvgpoolDMA and get executed by calling Cy_NNLite_TriggerDMAQueue. </p>
<p>API will work in blocking mode if callback function is passed as NULL in kernel context</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dmaQueue</td><td>dma queue pointer in which dma queue will be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Refer</td><td><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80cc663bc1668fe1a9167335e8985173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80cc663bc1668fe1a9167335e8985173">&#9670;&nbsp;</a></span>Cy_NNLite_KernelInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_KernelInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__kernel__config__t.html">cy_kernel_config_t</a> *&#160;</td>
          <td class="paramname"><em>kernelConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel Init API, initializes PDL driver and setup IRQ handler and setup function pointers from kernelConfig argument. </p>
<p>KernelConfig should have valid pointer for Mutex variable and function pointers for mutexCreate, mutexDelete, mutexLock, mutexUnlock and and should have valid pointers for Semaphore variable and function pointers for SemCreate, SemDelete, SemWait and SemGive for synchnization premitives. This API will allocate mutex and semaphore by calling mutexCreate and SemCreate, and will use them in successive call to other kernel public API's. API needs to be called before calling any other kernel API, If any of the pointers in KernelConfig is not valid API will return error code ,return value of API should be check to confirm successful initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernelConfig</td><td>kernel configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">cy_en_nnlite_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf938f97f72466428554fe4694cc25722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf938f97f72466428554fe4694cc25722">&#9670;&nbsp;</a></span>Cy_NNLite_KernelDeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__nnlite__enums.html#ga8714c4a5105d4130fb67c76b0d9a1920">cy_en_nnlite_status_t</a> Cy_NNLite_KernelDeInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel Deinit API, de-initialize PDL driver and synchronization primitives. </p>
<p>needs re initialization after this API is called. Should be called only at end of program</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">cy_en_nnlite_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
